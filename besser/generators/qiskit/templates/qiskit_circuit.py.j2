import sys
import os
sys.path = [p.strip() for p in sys.path if p]
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
from qiskit.circuit import Instruction
{% if backend_type == 'aer_simulator' %}
from qiskit_aer import AerSimulator
{% elif backend_type == 'fake_backend' %}
from qiskit_aer import AerSimulator
from qiskit_ibm_runtime.fake_provider import FakeManilaV2
{% elif backend_type == 'ibm_quantum' %}
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler
{% endif %}
from qiskit.circuit.library import *
from qiskit.circuit.library.standard_gates import GlobalPhaseGate
import numpy as np

{% if 'create_placeholder' in helper_classes %}
def create_placeholder(name, num_qubits):
    """Creates a placeholder instruction for unsupported gates."""
    qc_temp = QuantumCircuit(num_qubits, name=name)
    qc_temp.barrier()
    return qc_temp.to_instruction()

{% endif %}
{% if 'PhaseGradient' in helper_classes %}
class PhaseGradient(QuantumCircuit):
    """Phase Gradient Gate: applies |x⟩ → exp(2πix/2^n)|x⟩"""
    def __init__(self, num_qubits, inverse=False):
        super().__init__(num_qubits, name="PhaseGradient")
        for i in range(num_qubits):
            lam = 2 * np.pi / (2 ** (num_qubits - i))
            if inverse:
                lam = -lam
            self.p(lam, i)

{% endif %}
{% if 'ReverseBits' in helper_classes %}
class ReverseBits(QuantumCircuit):
    """Reverses the order of qubits."""
    def __init__(self, num_qubits):
        super().__init__(num_qubits, name="ReverseBits")
        for i in range(num_qubits // 2):
            self.swap(i, num_qubits - 1 - i)

{% endif %}
{% if 'Interleave' in helper_classes %}
class Interleave(QuantumCircuit):
    """Interleaves qubits: [a0,a1,b0,b1] -> [a0,b0,a1,b1]"""
    def __init__(self, num_qubits):
        super().__init__(num_qubits, name="Interleave")
        if num_qubits >= 4:
            half = num_qubits // 2
            for i in range(1, half):
                for j in range(i, half):
                    self.swap(half - j + i - 1, half - j + i)

{% endif %}
{% if 'Deinterleave' in helper_classes %}
class Deinterleave(QuantumCircuit):
    """Deinterleaves qubits: [a0,b0,a1,b1] -> [a0,a1,b0,b1]"""
    def __init__(self, num_qubits):
        super().__init__(num_qubits, name="Deinterleave")
        if num_qubits >= 4:
            half = num_qubits // 2
            for i in range(half - 1, 0, -1):
                for j in range(half - 1, i - 1, -1):
                    self.swap(half - j + i - 1, half - j + i)

{% endif %}
{% if 'RotateBitsLeft' in helper_classes %}
class RotateBitsLeft(QuantumCircuit):
    """Rotates qubits left: [q0,q1,q2] -> [q1,q2,q0]"""
    def __init__(self, num_qubits):
        super().__init__(num_qubits, name="RotateLeft")
        for i in range(num_qubits - 1):
            self.swap(i, i + 1)

{% endif %}
{% if 'RotateBitsRight' in helper_classes %}
class RotateBitsRight(QuantumCircuit):
    """Rotates qubits right: [q0,q1,q2] -> [q2,q0,q1]"""
    def __init__(self, num_qubits):
        super().__init__(num_qubits, name="RotateRight")
        for i in range(num_qubits - 1, 0, -1):
            self.swap(i, i - 1)

{% endif %}
{% if 'Increment' in helper_classes %}
class Increment(QuantumCircuit):
    """Increments a quantum register: |x⟩ -> |x+1⟩"""
    def __init__(self, num_qubits):
        super().__init__(num_qubits, name="+1")
        for i in range(num_qubits - 1, -1, -1):
            self.mcx(list(range(i)), i) if i > 0 else self.x(0)

{% endif %}
{% if 'Decrement' in helper_classes %}
class Decrement(QuantumCircuit):
    """Decrements a quantum register: |x⟩ -> |x-1⟩"""
    def __init__(self, num_qubits):
        super().__init__(num_qubits, name="-1")
        for i in range(num_qubits):
            if i > 0:
                for j in range(i):
                    self.x(j)
                self.mcx(list(range(i)), i)
                for j in range(i):
                    self.x(j)
            else:
                self.x(0)

{% endif %}
# Function Gate Definitions
{% for func_code in function_gates_code %}
{{ func_code }}
{% endfor %}


# Initialize Registers
{% for qreg in circuit.qregs %}
{{ qreg.name }} = QuantumRegister({{ qreg.size }}, '{{ qreg.name }}')
{% endfor %}
{% for creg in circuit.cregs %}
{{ creg.name }} = ClassicalRegister({{ creg.size }}, '{{ creg.name }}')
{% endfor %}

# Initialize Circuit
qc = QuantumCircuit({% for qreg in circuit.qregs %}{{ qreg.name }}{% if not loop.last %}, {% endif %}{% endfor %}{% if circuit.qregs and circuit.cregs %}, {% endif %}{% for creg in circuit.cregs %}{{ creg.name }}{% if not loop.last %}, {% endif %}{% endfor %})

# Operations
{% for line in operations_code %}
{{ line }}
{% endfor %}

# Draw
print(qc.draw())

{% if backend_type == 'aer_simulator' %}
# Execution (Local Aer Simulator)
print("Simulating circuit with Aer Simulator...")
simulator = AerSimulator()
transpiled_qc = transpile(qc, simulator)
result = simulator.run(transpiled_qc, shots={{ shots }}).result()
counts = result.get_counts()
print("Counts:", counts)
{% elif backend_type == 'fake_backend' %}
# Execution (Fake Backend - simulates real hardware noise)
print("Simulating circuit with Fake Backend (FakeManilaV2)...")
fake_backend = FakeManilaV2()
# Note: Fake backends simulate noise characteristics of real hardware
transpiled_qc = transpile(qc, fake_backend)
simulator = AerSimulator.from_backend(fake_backend)
result = simulator.run(transpiled_qc, shots={{ shots }}).result()
counts = result.get_counts()
print("Counts:", counts)
{% elif backend_type == 'ibm_quantum' %}
# Execution (IBM Quantum Hardware)
print("Running circuit on IBM Quantum Hardware...")

# Initialize the service (requires IBMQ account setup)
# To save your credentials: QiskitRuntimeService.save_account(channel="ibm_quantum", token="YOUR_TOKEN")
service = QiskitRuntimeService()

# Get the least busy backend that can handle this circuit
backend = service.least_busy(operational=True, simulator=False, min_num_qubits=qc.num_qubits)
print(f"Using backend: {backend.name}")

# Transpile for the target backend
transpiled_qc = transpile(qc, backend)

# Run using the Sampler primitive
sampler = Sampler(mode=backend)
job = sampler.run([transpiled_qc], shots={{ shots }})
print(f"Job ID: {job.job_id()}")

# Wait for results
result = job.result()
# Get quasi-distribution from the first pub result
pub_result = result[0]
counts = pub_result.data.meas.get_counts()
print("Counts:", counts)
{% endif %}
