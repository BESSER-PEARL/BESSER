"""
GitHub Service for Repository Creation and Code Push.

Handles creating GitHub repositories and pushing generated code.
"""

import os
import base64
import tempfile
import shutil
from typing import Optional, Dict, Any, List
from pathlib import Path
import requests
from datetime import datetime


class GitHubService:
    """Service for interacting with GitHub API."""
    
    def __init__(self, access_token: str):
        """
        Initialize GitHub service with user's access token.
        
        Args:
            access_token: GitHub OAuth access token
        """
        self.access_token = access_token
        self.base_url = "https://api.github.com"
        self.headers = {
            "Authorization": f"Bearer {access_token}",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28"
        }
    
    def get_authenticated_user(self) -> Dict[str, Any]:
        """
        Get information about the authenticated user.
        
        Returns:
            User information dictionary
        """
        response = requests.get(
            f"{self.base_url}/user",
            headers=self.headers,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    
    def create_repository(
        self,
        repo_name: str,
        description: str = "Web application generated by BESSER",
        is_private: bool = False
    ) -> Dict[str, Any]:
        """
        Create a new GitHub repository in user's account.
        
        Args:
            repo_name: Name for the repository
            description: Repository description
            is_private: Whether to make the repository private
            
        Returns:
            Repository information dictionary
        """
        data = {
            "name": repo_name,
            "description": description,
            "private": is_private,
            "auto_init": False,  # We'll push code ourselves
            "has_issues": True,
            "has_projects": False,
            "has_wiki": False
        }
        
        response = requests.post(
            f"{self.base_url}/user/repos",
            headers=self.headers,
            json=data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    
    def delete_repository(self, owner: str, repo_name: str) -> bool:
        """
        Delete a repository (use with caution!).
        
        Args:
            owner: Repository owner username
            repo_name: Repository name
            
        Returns:
            True if deleted successfully
        """
        response = requests.delete(
            f"{self.base_url}/repos/{owner}/{repo_name}",
            headers=self.headers,
            timeout=10
        )
        return response.status_code == 204
    
    def push_directory_to_repo(
        self,
        owner: str,
        repo_name: str,
        directory_path: str,
        commit_message: str = "Initial commit - Generated by BESSER"
    ) -> Dict[str, Any]:
        """
        Push entire directory contents to GitHub repository.
        
        Uses GitHub Contents API to upload files one by one.
        For large repos, consider using git push instead.
        
        Args:
            owner: Repository owner username
            repo_name: Repository name
            directory_path: Path to directory containing files to push
            commit_message: Commit message
            
        Returns:
            Dictionary with push results
        """
        results = {
            "uploaded_files": [],
            "failed_files": [],
            "total_files": 0
        }
        
        directory = Path(directory_path)
        
        # Get all files recursively
        all_files = list(directory.rglob("*"))
        all_files = [f for f in all_files if f.is_file()]
        
        results["total_files"] = len(all_files)
        
        for file_path in all_files:
            try:
                # Get relative path from directory
                rel_path = file_path.relative_to(directory)
                github_path = str(rel_path).replace("\\", "/")
                
                # Read file content
                with open(file_path, "rb") as f:
                    content = f.read()
                
                # Encode to base64
                content_b64 = base64.b64encode(content).decode("utf-8")
                
                # Upload to GitHub
                self._upload_file(
                    owner=owner,
                    repo_name=repo_name,
                    file_path=github_path,
                    content_b64=content_b64,
                    message=commit_message
                )
                
                results["uploaded_files"].append(github_path)
                
            except Exception as e:
                results["failed_files"].append({
                    "file": str(file_path),
                    "error": str(e)
                })
        
        return results
    
    def _upload_file(
        self,
        owner: str,
        repo_name: str,
        file_path: str,
        content_b64: str,
        message: str
    ) -> Dict[str, Any]:
        """
        Upload a single file to GitHub repository.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            file_path: Path within repository
            content_b64: Base64-encoded file content
            message: Commit message
            
        Returns:
            Response from GitHub API
        """
        data = {
            "message": message,
            "content": content_b64
        }
        
        response = requests.put(
            f"{self.base_url}/repos/{owner}/{repo_name}/contents/{file_path}",
            headers=self.headers,
            json=data,
            timeout=30
        )
        response.raise_for_status()
        return response.json()
    
    def create_readme(
        self,
        owner: str,
        repo_name: str,
        app_name: str,
        deploy_instructions: bool = True
    ) -> Dict[str, Any]:
        """
        Create a README.md file with deployment instructions.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            app_name: Application name
            deploy_instructions: Include deployment instructions
            
        Returns:
            GitHub API response
        """
        readme_content = self._generate_readme(app_name, deploy_instructions)
        content_b64 = base64.b64encode(readme_content.encode("utf-8")).decode("utf-8")
        
        return self._upload_file(
            owner=owner,
            repo_name=repo_name,
            file_path="README.md",
            content_b64=content_b64,
            message="Add README with deployment instructions"
        )
    
    def _generate_readme(self, app_name: str, deploy_instructions: bool) -> str:
        """Generate README.md content."""
        readme = f"""# {app_name}

Web application generated by [BESSER](https://github.com/BESSER-PEARL/BESSER).

## About

This application was created using the BESSER Web Modeling Editor, a low-code open-source platform for building software.

"""
        
        if deploy_instructions:
            readme += """## Project Structure

```
â”œâ”€â”€ frontend/          # React TypeScript frontend
â”œâ”€â”€ backend/           # FastAPI Python backend
â”œâ”€â”€ agent/            # BESSER agent (if included)
â”œâ”€â”€ render.yaml       # Render deployment config (one-click deploy!)
â”œâ”€â”€ .env.production   # Production environment variables
â””â”€â”€ docker-compose.yml # Local development setup
```

## ðŸš€ Deploy to Cloud

### One-Click Deployment with Render
[![Deploy to Render](https://render.com/images/deploy-to-render-button.svg)](https://render.com/deploy?repo=https://github.com/{owner}/{repo})

**Why Render?**
- âœ… **Free Tier** - 750 hours/month for both frontend + backend
- âœ… **One-Click Deploy** - No manual configuration needed
- âœ… **No Payment Info Required** - Won't ask for credit card
- âœ… **Auto SSL** - Free HTTPS certificates
- âš ï¸ Spins down after 15 min idle (cold start ~30s on first request)

Click the button above and Render will automatically:
1. Deploy your FastAPI backend
2. Deploy your React frontend
3. Connect them together
4. Give you live URLs

## Local Development

### Frontend
```bash
cd frontend
npm install
npm start
# Opens at http://localhost:3000
```

### Backend
```bash
cd backend
pip install -r requirements.txt
uvicorn main_api:app --reload
# API at http://localhost:8000
```

### Docker (Full Stack)
```bash
docker-compose up
# Frontend: http://localhost:3000
# Backend: http://localhost:8000
```

## Technology Stack

- **Frontend**: React with TypeScript, Create React App
- **Backend**: FastAPI (Python 3.9+)
- **Agent**: BESSER agent framework (optional)

## Generated by BESSER

Learn more about BESSER:
- [GitHub](https://github.com/BESSER-PEARL/BESSER)
- [Documentation](https://besser.readthedocs.io/)
- [Web Editor](https://editor.besser-pearl.org/)

---

"""
        
        return readme
    
    def get_deployment_urls(
        self,
        owner: str,
        repo_name: str
    ) -> Dict[str, str]:
        """
        Get deployment URLs for Render platform.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            
        Returns:
            Dictionary with GitHub and Render deployment URLs
        """
        repo_url = f"https://github.com/{owner}/{repo_name}"
        
        return {
            "github": repo_url,
            "render": f"https://render.com/deploy?repo={repo_url}"
        }
    
    def get_user_repositories(
        self,
        per_page: int = 100,
        sort: str = "updated"
    ) -> List[Dict[str, Any]]:
        """
        Get list of repositories for the authenticated user.
        
        Args:
            per_page: Number of repositories per page (max 100)
            sort: Sort by 'created', 'updated', 'pushed', 'full_name'
            
        Returns:
            List of repository information dictionaries
        """
        params = {
            "per_page": min(per_page, 100),
            "sort": sort,
            "affiliation": "owner"  # Only repos owned by user
        }
        
        response = requests.get(
            f"{self.base_url}/user/repos",
            headers=self.headers,
            params=params,
            timeout=15
        )
        response.raise_for_status()
        
        repos = response.json()
        # Return simplified repo info
        return [
            {
                "id": r.get("id"),
                "name": r.get("name"),
                "full_name": r.get("full_name"),
                "description": r.get("description"),
                "html_url": r.get("html_url"),
                "private": r.get("private"),
                "updated_at": r.get("updated_at"),
                "default_branch": r.get("default_branch", "main"),
            }
            for r in repos
        ]
    
    def get_commits(
        self,
        owner: str,
        repo_name: str,
        path: Optional[str] = None,
        per_page: int = 30
    ) -> List[Dict[str, Any]]:
        """
        Get commit history for a repository or specific file.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            path: Optional file path to filter commits
            per_page: Number of commits to return
            
        Returns:
            List of commit information dictionaries
        """
        params = {"per_page": per_page}
        if path:
            params["path"] = path
        
        response = requests.get(
            f"{self.base_url}/repos/{owner}/{repo_name}/commits",
            headers=self.headers,
            params=params,
            timeout=15
        )
        response.raise_for_status()
        
        commits = response.json()
        return [
            {
                "sha": c.get("sha"),
                "message": c.get("commit", {}).get("message", ""),
                "author": c.get("commit", {}).get("author", {}).get("name", "Unknown"),
                "date": c.get("commit", {}).get("author", {}).get("date", ""),
                "html_url": c.get("html_url", ""),
            }
            for c in commits
        ]
    
    def get_file_content(
        self,
        owner: str,
        repo_name: str,
        file_path: str,
        branch: str = "main",
        ref: Optional[str] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Get content of a file from the repository.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            file_path: Path to file in repository
            branch: Branch name (ignored if ref is provided)
            ref: Specific commit SHA to get file from (optional)
            
        Returns:
            Dictionary with file content and metadata, or None if not found
        """
        # Use ref (commit SHA) if provided, otherwise use branch
        params = {"ref": ref if ref else branch}
        
        response = requests.get(
            f"{self.base_url}/repos/{owner}/{repo_name}/contents/{file_path}",
            headers=self.headers,
            params=params,
            timeout=15
        )
        
        if response.status_code == 404:
            return None
        
        response.raise_for_status()
        data = response.json()
        
        # Decode content from base64
        content = None
        if data.get("content"):
            content = base64.b64decode(data["content"]).decode("utf-8")
        
        return {
            "sha": data.get("sha"),
            "content": content,
            "path": data.get("path"),
            "size": data.get("size"),
        }
    
    def create_or_update_file(
        self,
        owner: str,
        repo_name: str,
        file_path: str,
        content: str,
        commit_message: str,
        branch: str = "main"
    ) -> Dict[str, Any]:
        """
        Create or update a file in the repository.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            file_path: Path to file in repository
            content: File content (string)
            commit_message: Commit message
            branch: Branch name
            
        Returns:
            API response with commit info
        """
        # Check if file exists to get its SHA
        existing = self.get_file_content(owner, repo_name, file_path, branch)
        
        # Encode content
        content_b64 = base64.b64encode(content.encode("utf-8")).decode("utf-8")
        
        data = {
            "message": commit_message,
            "content": content_b64,
            "branch": branch
        }
        
        # If file exists, include SHA for update
        if existing and existing.get("sha"):
            data["sha"] = existing["sha"]
        
        response = requests.put(
            f"{self.base_url}/repos/{owner}/{repo_name}/contents/{file_path}",
            headers=self.headers,
            json=data,
            timeout=30
        )
        response.raise_for_status()
        
        result = response.json()
        return {
            "commit_sha": result.get("commit", {}).get("sha"),
            "content_sha": result.get("content", {}).get("sha"),
        }


def create_github_service(access_token: str) -> GitHubService:
    """
    Factory function to create GitHub service instance.
    
    Args:
        access_token: GitHub OAuth access token
        
    Returns:
        GitHubService instance
    """
    return GitHubService(access_token)
