"""
GitHub Deployment API - Deploy generated apps to user's GitHub account.

This endpoint generates a web app and pushes it to a GitHub repository
in the user's account, enabling one-click deployment to platforms like Render.
"""

import io
import os
import uuid
import zipfile
import tempfile
import shutil
import json
from typing import Optional, List
from datetime import datetime

from fastapi import APIRouter, HTTPException, Request, Body, Header, Query
from pydantic import BaseModel, Field

from besser.utilities.web_modeling_editor.backend.services.deployment.github_service import (
    create_github_service
)
from besser.utilities.web_modeling_editor.backend.services.deployment.github_oauth import (
    get_user_token
)
from besser.utilities.web_modeling_editor.backend.services.converters import (
    process_class_diagram,
    process_gui_diagram,
    process_agent_diagram,
)
from besser.utilities.web_modeling_editor.backend.config import get_generator_info


# Create router
router = APIRouter(prefix="/github", tags=["GitHub Deployment"])


class DeployToGitHubRequest(BaseModel):
    """Request model for GitHub deployment."""
    repo_name: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Repository name (alphanumeric, hyphens, underscores)"
    )
    description: Optional[str] = Field(
        None,
        max_length=350,
        description="Repository description"
    )
    is_private: bool = Field(
        default=False,
        description="Make repository private"
    )


class DeployToGitHubResponse(BaseModel):
    """Response model for GitHub deployment."""
    success: bool
    repo_url: str
    repo_name: str
    owner: str
    deployment_urls: dict
    files_uploaded: int
    message: str


@router.post("/deploy-webapp", response_model=DeployToGitHubResponse)
async def deploy_webapp_to_github(
    request: Request,
    body: dict = Body(...),
    github_session: Optional[str] = Header(None, alias="X-GitHub-Session")
):
    """
    Deploy generated web application to user's GitHub repository.
    
    Flow:
    1. Verify user has authenticated with GitHub
    2. Generate web app from project diagrams
    3. Create repository in user's GitHub account
    4. Push generated code to repository
    5. Return repository URL and deployment links
    
    The user can then deploy to Render with one click.
    """
    temp_dir = None
    
    try:
        # Verify GitHub authentication
        if not github_session:
            raise HTTPException(
                status_code=401,
                detail="GitHub authentication required. Please sign in with GitHub first."
            )
        
        access_token = get_user_token(github_session)
        if not access_token:
            raise HTTPException(
                status_code=401,
                detail="GitHub session expired. Please sign in again."
            )
        
        # Create GitHub service
        github = create_github_service(access_token)
        
        # Get authenticated user info
        user_info = github.get_authenticated_user()
        username = user_info.get("login")
        
        # Extract deploy config
        deploy_config = body.get("deploy_config", {})
        repo_name = deploy_config.get("repo_name", "besser-webapp")
        description = deploy_config.get("description", "Web application generated by BESSER")
        is_private = deploy_config.get("is_private", False)
        
        # Sanitize repo name
        repo_name = _sanitize_repo_name(repo_name)
        
        # Extract diagrams
        diagrams = body.get("diagrams", {})
        class_diagram_data = diagrams.get("ClassDiagram", {})
        gui_diagram_data = diagrams.get("GUINoCodeDiagram", {})
        
        if not class_diagram_data or not class_diagram_data.get("model"):
            raise HTTPException(
                status_code=400,
                detail="ClassDiagram is required for web app deployment"
            )
        
        if not gui_diagram_data or not gui_diagram_data.get("model"):
            raise HTTPException(
                status_code=400,
                detail="GUINoCodeDiagram is required for web app deployment"
            )
        
        # Process diagrams to BUML
        buml_model = process_class_diagram(class_diagram_data)
        gui_model = process_gui_diagram(
            gui_diagram_data.get("model"),
            class_diagram_data.get("model"),
            buml_model
        )
        
        # Check for agent diagram
        agent_model = None
        agent_diagram_data = diagrams.get("AgentDiagram", {})
        if agent_diagram_data and agent_diagram_data.get("model"):
            agent_model = process_agent_diagram(agent_diagram_data)
        
        # Generate web app
        temp_dir = tempfile.mkdtemp(prefix=f"besser_github_{uuid.uuid4().hex}_")
        
        generator_info = get_generator_info("web_app")
        generator_class = generator_info.generator_class
        generator = generator_class(
            buml_model,
            gui_model,
            output_dir=temp_dir,
            agent_model=agent_model
        )
        generator.generate()
        
        # Add deployment configuration files
        _add_deployment_configs(temp_dir, repo_name, has_agent=agent_model is not None)
        
        # Create GitHub repository
        repo_info = github.create_repository(
            repo_name=repo_name,
            description=description,
            is_private=is_private
        )
        
        repo_full_name = repo_info.get("full_name")
        repo_url = repo_info.get("html_url")
        
        # Push code to repository
        push_results = github.push_directory_to_repo(
            owner=username,
            repo_name=repo_name,
            directory_path=temp_dir,
            commit_message="Initial commit - Generated by BESSER Web Editor"
        )
        
        # Create README with deployment instructions
        github.create_readme(
            owner=username,
            repo_name=repo_name,
            app_name=body.get("name", repo_name),
            deploy_instructions=True
        )
        
        # Get deployment URLs
        deployment_urls = github.get_deployment_urls(username, repo_name)
        
        return DeployToGitHubResponse(
            success=True,
            repo_url=repo_url,
            repo_name=repo_name,
            owner=username,
            deployment_urls=deployment_urls,
            files_uploaded=len(push_results["uploaded_files"]) + 1,  # +1 for README
            message=f"Successfully created repository and pushed {len(push_results['uploaded_files'])} files"
        )
        
    except HTTPException:
        raise
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to deploy to GitHub: {str(e)}"
        )
    finally:
        if temp_dir and os.path.exists(temp_dir):
            shutil.rmtree(temp_dir, ignore_errors=True)


def _sanitize_repo_name(name: str) -> str:
    """
    Sanitize repository name to meet GitHub requirements.
    
    - Lowercase
    - Replace spaces with hyphens
    - Remove special characters
    - Max 100 characters
    """
    # Convert to lowercase
    name = name.lower()
    
    # Replace spaces with hyphens
    name = name.replace(" ", "-")
    
    # Remove special characters (keep only alphanumeric, hyphens, underscores)
    name = "".join(c for c in name if c.isalnum() or c in "-_")
    
    # Remove leading/trailing hyphens
    name = name.strip("-_")
    
    # Limit length
    name = name[:100]
    
    # Ensure not empty
    if not name:
        name = f"besser-app-{uuid.uuid4().hex[:8]}"
    
    return name


def _add_deployment_configs(directory: str, app_name: str, has_agent: bool = False):
    """
    Add Render deployment configuration (only free platform for full-stack auto-deploy).
    
    Args:
        directory: Path to generated app directory
        app_name: Application name
        has_agent: Whether the app includes an agent service
    """
    # Render configuration - Full stack (backend + frontend + optional agent)
    render_config = f"""services:
  # Backend API (Free tier - 750 hours/month, spins down after 15 min idle)
  - type: web
    name: {app_name}-backend
    runtime: python
    plan: free
    buildCommand: pip install -r backend/requirements.txt
    startCommand: cd backend && uvicorn main_api:app --host 0.0.0.0 --port $PORT
    envVars:
      - key: PYTHON_VERSION
        value: 3.9.16
      - key: PORT
        value: 8000

  # Frontend (Free static site)
  - type: web
    name: {app_name}-frontend  
    runtime: static
    buildCommand: cd frontend && npm install && npm run build
    staticPublishPath: frontend/build
    routes:
      - type: rewrite
        source: /*
        destination: /index.html
"""
    
    # Add agent service if the app includes an agent
    if has_agent:
        agent_config = f"""
  # Agent Service (Free tier - WebSocket-based AI agent)
  - type: web
    name: {app_name}-agent
    runtime: python
    plan: free
    buildCommand: pip install -r agent/requirements.txt
    startCommand: cd agent && python main.py
    envVars:
      - key: PYTHON_VERSION
        value: 3.9.16
      - key: PORT
        value: 8765
"""
        render_config += agent_config
    
    render_path = os.path.join(directory, "render.yaml")
    with open(render_path, "w") as f:
        f.write(render_config)
    
    # Create .env.production for frontend with backend URL (and agent URL if applicable)
    env_production = f"""# Production environment variables
# Backend API URL - Update this with your deployed backend URL
REACT_APP_API_URL=https://{app_name}-backend.onrender.com
"""
    
    if has_agent:
        env_production += f"""# Agent WebSocket URL - Update this with your deployed agent URL
REACT_APP_AGENT_URL=wss://{app_name}-agent.onrender.com
"""
    
    env_production += """
# For local development, use: http://localhost:8000 (backend) and ws://localhost:8765 (agent)
"""
    
    env_prod_path = os.path.join(directory, "frontend", ".env.production")
    with open(env_prod_path, "w") as f:
        f.write(env_production)
    
    # Create .env for local development
    env_local = """# Local development environment variables
REACT_APP_API_URL=http://localhost:8000
"""
    
    if has_agent:
        env_local += """REACT_APP_AGENT_URL=ws://localhost:8765
"""
    
    env_local_path = os.path.join(directory, "frontend", ".env")
    with open(env_local_path, "w") as f:
        f.write(env_local)


# ============================================================================
# GitHub Project Storage API
# ============================================================================

class GitHubRepoResponse(BaseModel):
    """Repository information response."""
    id: int
    name: str
    full_name: str
    description: Optional[str]
    html_url: str
    private: bool
    updated_at: str
    default_branch: str


class GitHubReposListResponse(BaseModel):
    """Response for list of repositories."""
    repositories: List[GitHubRepoResponse]


class GitHubCommitResponse(BaseModel):
    """Commit information response."""
    sha: str
    message: str
    author: str
    date: str
    html_url: str


class GitHubCommitsListResponse(BaseModel):
    """Response for list of commits."""
    commits: List[GitHubCommitResponse]


class SaveProjectRequest(BaseModel):
    """Request to save project to GitHub."""
    owner: str
    repo: str
    branch: str = "main"
    file_path: str = "besser-project.json"
    commit_message: str
    project_data: dict


class SaveProjectResponse(BaseModel):
    """Response for project save."""
    success: bool
    commit_sha: str
    message: str


class LoadProjectResponse(BaseModel):
    """Response for project load."""
    success: bool
    project: dict
    sha: str


class LoadProjectFromCommitResponse(BaseModel):
    """Response for loading project from specific commit."""
    success: bool
    project: dict
    commit_sha: str
    commit_message: str
    commit_date: str


class CreateRepoForProjectRequest(BaseModel):
    """Request to create a new repo and save project."""
    repo_name: str
    description: str = ""
    is_private: bool = False
    project_data: dict


class CreateRepoForProjectResponse(BaseModel):
    """Response for creating repo with project."""
    success: bool
    repo_url: str
    owner: str
    commit_sha: str
    message: str


@router.get("/repos", response_model=GitHubReposListResponse)
async def get_user_repositories(
    github_session: Optional[str] = Header(None, alias="X-GitHub-Session")
):
    """
    Get list of repositories for the authenticated user.
    
    Returns only repositories owned by the user, sorted by last updated.
    """
    if not github_session:
        raise HTTPException(status_code=401, detail="GitHub authentication required")
    
    access_token = get_user_token(github_session)
    if not access_token:
        raise HTTPException(status_code=401, detail="GitHub session expired")
    
    try:
        github = create_github_service(access_token)
        repos = github.get_user_repositories()
        
        return GitHubReposListResponse(
            repositories=[GitHubRepoResponse(**r) for r in repos]
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to fetch repositories: {str(e)}")


@router.get("/commits", response_model=GitHubCommitsListResponse)
async def get_repository_commits(
    owner: str = Query(..., description="Repository owner"),
    repo: str = Query(..., description="Repository name"),
    path: Optional[str] = Query(None, description="File path to filter commits"),
    github_session: Optional[str] = Header(None, alias="X-GitHub-Session")
):
    """
    Get commit history for a repository or specific file.
    """
    if not github_session:
        raise HTTPException(status_code=401, detail="GitHub authentication required")
    
    access_token = get_user_token(github_session)
    if not access_token:
        raise HTTPException(status_code=401, detail="GitHub session expired")
    
    try:
        github = create_github_service(access_token)
        commits = github.get_commits(owner, repo, path)
        
        return GitHubCommitsListResponse(
            commits=[GitHubCommitResponse(**c) for c in commits]
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to fetch commits: {str(e)}")


@router.post("/project/save", response_model=SaveProjectResponse)
async def save_project_to_github(
    request: SaveProjectRequest,
    github_session: Optional[str] = Header(None, alias="X-GitHub-Session")
):
    """
    Save a BESSER project to a GitHub repository.
    
    Creates or updates the project JSON file in the specified repository.
    """
    if not github_session:
        raise HTTPException(status_code=401, detail="GitHub authentication required")
    
    access_token = get_user_token(github_session)
    if not access_token:
        raise HTTPException(status_code=401, detail="GitHub session expired")
    
    try:
        github = create_github_service(access_token)
        
        # Convert project data to JSON string
        project_json = json.dumps(request.project_data, indent=2)
        
        # Save to GitHub
        result = github.create_or_update_file(
            owner=request.owner,
            repo_name=request.repo,
            file_path=request.file_path,
            content=project_json,
            commit_message=request.commit_message,
            branch=request.branch
        )
        
        return SaveProjectResponse(
            success=True,
            commit_sha=result.get("commit_sha", ""),
            message=f"Project saved successfully"
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to save project: {str(e)}")


@router.get("/project/load", response_model=LoadProjectResponse)
async def load_project_from_github(
    owner: str = Query(..., description="Repository owner"),
    repo: str = Query(..., description="Repository name"),
    branch: str = Query("main", description="Branch name"),
    file_path: str = Query("besser-project.json", description="Project file path"),
    github_session: Optional[str] = Header(None, alias="X-GitHub-Session")
):
    """
    Load a BESSER project from a GitHub repository.
    """
    if not github_session:
        raise HTTPException(status_code=401, detail="GitHub authentication required")
    
    access_token = get_user_token(github_session)
    if not access_token:
        raise HTTPException(status_code=401, detail="GitHub session expired")
    
    try:
        github = create_github_service(access_token)
        
        # Get file content
        file_data = github.get_file_content(owner, repo, file_path, branch)
        
        if not file_data:
            raise HTTPException(
                status_code=404, 
                detail=f"Project file not found: {file_path}"
            )
        
        # Parse JSON content
        project = json.loads(file_data.get("content", "{}"))
        
        return LoadProjectResponse(
            success=True,
            project=project,
            sha=file_data.get("sha", "")
        )
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Invalid project file format")
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to load project: {str(e)}")


@router.get("/project/load-commit", response_model=LoadProjectFromCommitResponse)
async def load_project_from_commit(
    owner: str = Query(..., description="Repository owner"),
    repo: str = Query(..., description="Repository name"),
    commit_sha: str = Query(..., description="Commit SHA to load from"),
    file_path: str = Query("besser-project.json", description="Project file path"),
    github_session: Optional[str] = Header(None, alias="X-GitHub-Session")
):
    """
    Load a BESSER project from a specific commit in a GitHub repository.
    
    This allows restoring previous versions of the project.
    """
    if not github_session:
        raise HTTPException(status_code=401, detail="GitHub authentication required")
    
    access_token = get_user_token(github_session)
    if not access_token:
        raise HTTPException(status_code=401, detail="GitHub session expired")
    
    try:
        github = create_github_service(access_token)
        
        # Get file content at specific commit
        file_data = github.get_file_content(owner, repo, file_path, ref=commit_sha)
        
        if not file_data:
            raise HTTPException(
                status_code=404, 
                detail=f"Project file not found at commit {commit_sha[:7]}"
            )
        
        # Parse JSON content
        project = json.loads(file_data.get("content", "{}"))
        
        # Get commit info for display
        commits = github.get_commits(owner, repo, file_path, per_page=100)
        commit_info = next((c for c in commits if c["sha"] == commit_sha), None)
        
        return LoadProjectFromCommitResponse(
            success=True,
            project=project,
            commit_sha=commit_sha,
            commit_message=commit_info.get("message", "") if commit_info else "",
            commit_date=commit_info.get("date", "") if commit_info else ""
        )
    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Invalid project file format")
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to load project from commit: {str(e)}")


@router.post("/project/create-repo", response_model=CreateRepoForProjectResponse)
async def create_repository_for_project(
    request: CreateRepoForProjectRequest,
    github_session: Optional[str] = Header(None, alias="X-GitHub-Session")
):
    """
    Create a new GitHub repository and save the project to it.
    
    This is a convenience endpoint that:
    1. Creates a new repository in the user's account
    2. Saves the project JSON as the initial commit
    3. Creates a README.md explaining the project
    """
    if not github_session:
        raise HTTPException(status_code=401, detail="GitHub authentication required")
    
    access_token = get_user_token(github_session)
    if not access_token:
        raise HTTPException(status_code=401, detail="GitHub session expired")
    
    try:
        github = create_github_service(access_token)
        
        # Get user info
        user_info = github.get_authenticated_user()
        username = user_info.get("login")
        
        # Sanitize repo name
        repo_name = _sanitize_repo_name(request.repo_name)
        
        # Create repository
        repo_info = github.create_repository(
            repo_name=repo_name,
            description=request.description or "BESSER project repository",
            is_private=request.is_private
        )
        
        # Save project to repo
        project_json = json.dumps(request.project_data, indent=2)
        save_result = github.create_or_update_file(
            owner=username,
            repo_name=repo_name,
            file_path="besser-project.json",
            content=project_json,
            commit_message=f"Initial commit: {request.project_data.get('name', 'BESSER Project')}",
            branch="main"
        )
        
        # Create README
        project_name = request.project_data.get("name", "BESSER Project")
        readme_content = f"""# {project_name}

BESSER project repository.

## About

This repository contains a [BESSER](https://github.com/BESSER-PEARL/BESSER) project.

## Files

- `besser-project.json` - The project definition file

## Opening the Project

1. Go to [BESSER Web Editor](https://editor.besser-pearl.org/)
2. Connect your GitHub account
3. Link this repository to load the project

## Learn More

- [BESSER GitHub](https://github.com/BESSER-PEARL/BESSER)
- [Documentation](https://besser.readthedocs.io/)

---
*Generated by BESSER Web Modeling Editor*
"""
        github.create_or_update_file(
            owner=username,
            repo_name=repo_name,
            file_path="README.md",
            content=readme_content,
            commit_message="Add README",
            branch="main"
        )
        
        return CreateRepoForProjectResponse(
            success=True,
            repo_url=repo_info.get("html_url", ""),
            owner=username,
            commit_sha=save_result.get("commit_sha", ""),
            message=f"Repository '{repo_name}' created with project"
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to create repository: {str(e)}")
