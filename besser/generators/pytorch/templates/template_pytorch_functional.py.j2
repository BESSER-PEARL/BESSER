{%- import "setup_nn_components.py.j2" as nn_components -%}
import torch.nn as nn
{% if train_data is not none %}import torch
{% if train_data.input_format == "images" %}from torchvision import datasets, transforms 
from besser.generators.pytorch.utils import compute_mean_std{%- endif %}
{% if train_data.task_type != "regression" %}from sklearn.metrics import classification_report 
{%- else -%} from sklearn.metrics import mean_absolute_error {%- endif %} 
{% if train_data.input_format == "csv" %}import pandas as pd {%- endif %}
{%- endif %}
{%- for module_name, module_details in modules_details.items() -%}{% if module_name.endswith("op") %}{% if module_details[0].startswith("torch") %}import torch {%- endif %}{%- endif %}{%- endfor %}


{%- set activ_func_list = [] %}

# Define the network architecture
class NeuralNetwork(nn.Module):
    def __init__(self):
        super().__init__()
        {%- for module_name, module_details in modules_details.items() %}
        {%- if module_name.endswith("nn") %}
        self.{{ module_name.split('_')[0] }} = nn.Sequential(
            {%- for subnn_key, subnn_value in module_details.items() %}
                {%- if subnn_key != "notation" %}
            {{ subnn_value[0].split('=', 1)[1].strip() }},
                {%- endif -%}
            {%- endfor %}
        )
        {%- elif module_name.endswith("activ") %}
                {%- if module_details[0] not in activ_func_list %}
                {%- set _ = activ_func_list.append(module_details[0])%}
        {{ module_details[0] }}
                {%- endif -%}
        {%- elif module_name.endswith("layer") %}
        {{ module_details[0] }}
        {%- endif -%}
        {%- endfor %}
    {% set return_notation =  namespace(value="") %}
    def forward(self, x):
    {%- for module_name, module_details in modules_details.items() -%}
    {%- if module_name.endswith("op") %}
        {{ module_details[1] }} = {{ module_details[0] }}
    {%- elif module_name.endswith("nn") %} 
        {{ module_details["notation"] }} = self.{{ module_name.rsplit('_', 2)[0] }}({{ module_details["notation"] }})
    {%- else %}
        {%- if module_name.endswith("activ") %}
        {{ module_details[1] }} = self.{{ module_details[0].split('.', 1)[1].split('=', 1)[0].strip() }}({{ module_details[2] }})
        {%- elif module_details[-1].__class__.mro()[1].__name__ == "RNN" %}

        {%- if module_details[-1].__class__.__name__ == "LSTMLayer" %}
                {%- if module_details[-1].return_hidden %}
        _, ({{ module_details[1] }}, _) = self.{{ module_name.rsplit('_', 1)[0] }}({{ module_details[2] }})
        {{ module_details[1] }} = {{ module_details[1] }}[-1]
        {%- elif module_details[-1].return_sequences %}
        {{ module_details[1] }}, _ = self.{{ module_name.rsplit('_', 1)[0] }}({{ module_details[2] }})
                {%- else %}
        {{ module_details[1] }}, _ = self.{{ module_name.rsplit('_', 1)[0] }}({{ module_details[2] }})
        {{ module_details[1] }} = {{ module_details[1] }}[:, -1, :]
                {%- endif -%}
        {%- else %}
            {%- if module_details[-1].return_hidden %}
        _, {{ module_details[1] }} = self.{{ module_name.rsplit('_', 1)[0] }}({{ module_details[2] }})
        {{ module_details[1] }} = {{ module_details[1] }}[-1]
            {%- elif module_details[-1].return_sequences %}
        {{ module_details[1] }}, _ = self.{{ module_name.rsplit('_', 1)[0] }}({{ module_details[2] }})
                {%- else %}
        {{ module_details[1] }}, _ = self.{{ module_name.rsplit('_', 1)[0] }}({{ module_details[2] }})
        {{ module_details[1] }} = {{ module_details[1] }}[:, -1, :]
        {%- endif -%}
        {%- endif -%}

        {%- else %} 
        {{ module_details[1] }} = self.{{ module_name.rsplit('_', 1)[0] }}({{ module_details[2] }})
        {%- endif -%}
    {%- endif -%}
    {%- if module_name.endswith("nn") %}
    {%- set return_notation.value =  module_details["notation"] %}
    {%- else %} 
    {%- set return_notation.value =  module_details[1] %}
    {%- endif -%}
    {%- endfor %}
        return {{ return_notation.value }}

{% if train_data is not none %}
# Dataset preparation
{{ nn_components.prepare_data(train_data, test_data, model.parameters) -}}

# Define the network, loss function, and optimiser
{{ model.name }} = NeuralNetwork()
criterion = {{ nn_components.get_loss_function(model.parameters) }}
optimiser = {{ nn_components.get_optimiser(model) }}

# Train the neural network
{{ nn_components.train_model(model, train_data.task_type) }}

# Evaluate the neural network
{{ nn_components.evaluate_model(model, train_data.task_type) }}
{%- endif -%}