"""
GitHub Service for Repository Creation and Code Push.

Handles creating GitHub repositories and pushing generated code.
"""

import os
import base64
import tempfile
import shutil
from typing import Optional, Dict, Any, List
from pathlib import Path
import requests
from datetime import datetime


class GitHubService:
    """Service for interacting with GitHub API."""
    
    def __init__(self, access_token: str):
        """
        Initialize GitHub service with user's access token.
        
        Args:
            access_token: GitHub OAuth access token
        """
        self.access_token = access_token
        self.base_url = "https://api.github.com"
        self.headers = {
            "Authorization": f"Bearer {access_token}",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28"
        }
    
    def get_authenticated_user(self) -> Dict[str, Any]:
        """
        Get information about the authenticated user.
        
        Returns:
            User information dictionary
        """
        response = requests.get(
            f"{self.base_url}/user",
            headers=self.headers,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    
    def create_repository(
        self,
        repo_name: str,
        description: str = "Web application generated by BESSER",
        is_private: bool = False,
        auto_init: bool = False
    ) -> Dict[str, Any]:
        """
        Create a new GitHub repository in user's account.
        
        Args:
            repo_name: Name for the repository
            description: Repository description
            is_private: Whether to make the repository private
            
        Returns:
            Repository information dictionary
        """
        data = {
            "name": repo_name,
            "description": description,
            "private": is_private,
            "auto_init": auto_init,
            "has_issues": True,
            "has_projects": False,
            "has_wiki": False
        }
        
        response = requests.post(
            f"{self.base_url}/user/repos",
            headers=self.headers,
            json=data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    
    def delete_repository(self, owner: str, repo_name: str) -> bool:
        """
        Delete a repository (use with caution!).
        
        Args:
            owner: Repository owner username
            repo_name: Repository name
            
        Returns:
            True if deleted successfully
        """
        response = requests.delete(
            f"{self.base_url}/repos/{owner}/{repo_name}",
            headers=self.headers,
            timeout=10
        )
        return response.status_code == 204
    
    def push_directory_to_repo(
        self,
        owner: str,
        repo_name: str,
        directory_path: str,
        commit_message: str = "Initial commit - Generated by BESSER",
        branch: str = "main"
    ) -> Dict[str, Any]:
        """
        Push entire directory contents to GitHub repository.
        
        Uses GitHub Git Data API to create a single commit.
        
        Args:
            owner: Repository owner username
            repo_name: Repository name
            directory_path: Path to directory containing files to push
            commit_message: Commit message
            branch: Target branch name
            
        Returns:
            Dictionary with push results
        """
        results = {
            "uploaded_files": [],
            "failed_files": [],
            "total_files": 0,
            "commit_sha": ""
        }
        
        directory = Path(directory_path)
        
        # Get all files recursively
        all_files = list(directory.rglob("*"))
        all_files = [f for f in all_files if f.is_file()]
        
        results["total_files"] = len(all_files)
        
        tree_entries = []
        for file_path in all_files:
            try:
                # Get relative path from directory
                rel_path = file_path.relative_to(directory)
                github_path = str(rel_path).replace("\\", "/")
                
                # Read file content
                with open(file_path, "rb") as f:
                    content = f.read()
                
                blob_sha = self._create_blob(
                    owner=owner,
                    repo_name=repo_name,
                    content=content
                )
                if not blob_sha:
                    raise ValueError("GitHub did not return a blob SHA.")
                tree_entries.append({
                    "path": github_path,
                    "mode": "100644",
                    "type": "blob",
                    "sha": blob_sha
                })
                
                results["uploaded_files"].append(github_path)
                
            except Exception as e:
                results["failed_files"].append({
                    "file": str(file_path),
                    "error": str(e)
                })
        
        if results["failed_files"]:
            first_error = results["failed_files"][0]
            raise RuntimeError(
                f"Failed to upload {len(results['failed_files'])} files. "
                f"First error: {first_error['file']} - {first_error['error']}"
            )

        if not tree_entries:
            raise RuntimeError("No files found to upload.")

        tree_sha = self._create_tree(owner, repo_name, tree_entries)
        parent_sha = self._get_ref_sha(owner, repo_name, branch)
        commit_sha = self._create_commit(
            owner=owner,
            repo_name=repo_name,
            message=commit_message,
            tree_sha=tree_sha,
            parent_sha=parent_sha
        )
        self._update_or_create_ref(owner, repo_name, branch, commit_sha, parent_sha)
        results["commit_sha"] = commit_sha
        
        return results
    
    def _upload_file(
        self,
        owner: str,
        repo_name: str,
        file_path: str,
        content_b64: str,
        message: str
    ) -> Dict[str, Any]:
        """
        Upload a single file to GitHub repository.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            file_path: Path within repository
            content_b64: Base64-encoded file content
            message: Commit message
            
        Returns:
            Response from GitHub API
        """
        data = {
            "message": message,
            "content": content_b64
        }
        
        response = requests.put(
            f"{self.base_url}/repos/{owner}/{repo_name}/contents/{file_path}",
            headers=self.headers,
            json=data,
            timeout=30
        )
        response.raise_for_status()
        return response.json()
    
    def create_readme(
        self,
        owner: str,
        repo_name: str,
        app_name: str,
        deploy_instructions: bool = True
    ) -> Dict[str, Any]:
        """
        Create a README.md file with deployment instructions.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            app_name: Application name
            deploy_instructions: Include deployment instructions
            
        Returns:
            GitHub API response
        """
        readme_content = self.generate_readme_content(app_name, deploy_instructions)
        content_b64 = base64.b64encode(readme_content.encode("utf-8")).decode("utf-8")
        
        return self._upload_file(
            owner=owner,
            repo_name=repo_name,
            file_path="README.md",
            content_b64=content_b64,
            message="Add README with deployment instructions"
        )
    
    def generate_readme_content(self, app_name: str, deploy_instructions: bool = True) -> str:
        """Generate README.md content."""
        readme = f"""# {app_name}

Web application generated by [BESSER](https://github.com/BESSER-PEARL/BESSER).

## About

This application was created using the BESSER Web Modeling Editor, a low-code open-source platform for building software.

"""
        
        if deploy_instructions:
            readme += """## Project Structure

```
â”œâ”€â”€ frontend/          # React TypeScript frontend
â”œâ”€â”€ backend/           # FastAPI Python backend
â”œâ”€â”€ agent/            # BESSER agent (if included)
â”œâ”€â”€ render.yaml       # Render deployment config (one-click deploy!)
â”œâ”€â”€ .env.production   # Production environment variables
â””â”€â”€ docker-compose.yml # Local development setup
```

## ðŸš€ Deploy to Cloud

### One-Click Deployment with Render
[![Deploy to Render](https://render.com/images/deploy-to-render-button.svg)](https://render.com/deploy?repo=https://github.com/{owner}/{repo})

**Why Render?**
- âœ… **Free Tier** - 750 hours/month for both frontend + backend
- âœ… **One-Click Deploy** - No manual configuration needed
- âœ… **No Payment Info Required** - Won't ask for credit card
- âœ… **Auto SSL** - Free HTTPS certificates
- âš ï¸ Spins down after 15 min idle (cold start ~30s on first request)

Click the button above and Render will automatically:
1. Deploy your FastAPI backend
2. Deploy your React frontend
3. Connect them together
4. Give you live URLs

## Local Development

### Frontend
```bash
cd frontend
npm install
npm start
# Opens at http://localhost:3000
```

### Backend
```bash
cd backend
pip install -r requirements.txt
uvicorn main_api:app --reload
# API at http://localhost:8000
```

### Docker (Full Stack)
```bash
docker-compose up
# Frontend: http://localhost:3000
# Backend: http://localhost:8000
```

## Technology Stack

- **Frontend**: React with TypeScript, Create React App
- **Backend**: FastAPI (Python 3.9+)
- **Agent**: BESSER agent framework (optional)

## Generated by BESSER

Learn more about BESSER:
- [GitHub](https://github.com/BESSER-PEARL/BESSER)
- [Documentation](https://besser.readthedocs.io/)
- [Web Editor](https://editor.besser-pearl.org/)

---

"""
        
        return readme

    def _create_blob(self, owner: str, repo_name: str, content: bytes) -> str:
        """Create a blob and return its SHA."""
        data = {
            "content": base64.b64encode(content).decode("utf-8"),
            "encoding": "base64"
        }
        response = requests.post(
            f"{self.base_url}/repos/{owner}/{repo_name}/git/blobs",
            headers=self.headers,
            json=data,
            timeout=30
        )
        response.raise_for_status()
        return response.json().get("sha", "")

    def _create_tree(self, owner: str, repo_name: str, tree: List[Dict[str, Any]]) -> str:
        """Create a tree and return its SHA."""
        response = requests.post(
            f"{self.base_url}/repos/{owner}/{repo_name}/git/trees",
            headers=self.headers,
            json={"tree": tree},
            timeout=30
        )
        response.raise_for_status()
        return response.json().get("sha", "")

    def _create_commit(
        self,
        owner: str,
        repo_name: str,
        message: str,
        tree_sha: str,
        parent_sha: Optional[str]
    ) -> str:
        """Create a commit and return its SHA."""
        payload = {
            "message": message,
            "tree": tree_sha,
            "parents": [parent_sha] if parent_sha else []
        }
        response = requests.post(
            f"{self.base_url}/repos/{owner}/{repo_name}/git/commits",
            headers=self.headers,
            json=payload,
            timeout=30
        )
        response.raise_for_status()
        return response.json().get("sha", "")

    def _get_ref_sha(self, owner: str, repo_name: str, branch: str) -> Optional[str]:
        """Get the current SHA for a branch ref, or None if it doesn't exist."""
        response = requests.get(
            f"{self.base_url}/repos/{owner}/{repo_name}/git/ref/heads/{branch}",
            headers=self.headers,
            timeout=10
        )
        if response.status_code == 404:
            return None
        response.raise_for_status()
        return response.json().get("object", {}).get("sha")

    def _update_or_create_ref(
        self,
        owner: str,
        repo_name: str,
        branch: str,
        commit_sha: str,
        parent_sha: Optional[str]
    ) -> None:
        """Update the branch ref if it exists, otherwise create it."""
        if parent_sha:
            response = requests.patch(
                f"{self.base_url}/repos/{owner}/{repo_name}/git/refs/heads/{branch}",
                headers=self.headers,
                json={"sha": commit_sha, "force": False},
                timeout=10
            )
            response.raise_for_status()
            return

        response = requests.post(
            f"{self.base_url}/repos/{owner}/{repo_name}/git/refs",
            headers=self.headers,
            json={"ref": f"refs/heads/{branch}", "sha": commit_sha},
            timeout=10
        )
        if response.status_code == 422:
            # Ref already exists; fall back to patch.
            response = requests.patch(
                f"{self.base_url}/repos/{owner}/{repo_name}/git/refs/heads/{branch}",
                headers=self.headers,
                json={"sha": commit_sha, "force": False},
                timeout=10
            )
        response.raise_for_status()
    
    def get_deployment_urls(
        self,
        owner: str,
        repo_name: str
    ) -> Dict[str, str]:
        """
        Get deployment URLs for Render platform.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            
        Returns:
            Dictionary with GitHub and Render deployment URLs
        """
        repo_url = f"https://github.com/{owner}/{repo_name}"
        
        return {
            "github": repo_url,
            "render": f"https://render.com/deploy?repo={repo_url}"
        }
    
    def get_user_repositories(
        self,
        per_page: int = 100,
        sort: str = "updated"
    ) -> List[Dict[str, Any]]:
        """
        Get list of repositories for the authenticated user.
        
        Args:
            per_page: Number of repositories per page (max 100)
            sort: Sort by 'created', 'updated', 'pushed', 'full_name'
            
        Returns:
            List of repository information dictionaries
        """
        params = {
            "per_page": min(per_page, 100),
            "sort": sort,
            "affiliation": "owner"  # Only repos owned by user
        }
        
        response = requests.get(
            f"{self.base_url}/user/repos",
            headers=self.headers,
            params=params,
            timeout=15
        )
        response.raise_for_status()
        
        repos = response.json()
        # Return simplified repo info
        return [
            {
                "id": r.get("id"),
                "name": r.get("name"),
                "full_name": r.get("full_name"),
                "description": r.get("description"),
                "html_url": r.get("html_url"),
                "private": r.get("private"),
                "updated_at": r.get("updated_at"),
                "default_branch": r.get("default_branch", "main"),
            }
            for r in repos
        ]
    
    def get_branches(
        self,
        owner: str,
        repo_name: str,
        per_page: int = 100
    ) -> List[str]:
        """
        Get list of branches for a repository.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            per_page: Number of branches per page (max 100)
            
        Returns:
            List of branch names
        """
        params = {"per_page": min(per_page, 100)}
        
        response = requests.get(
            f"{self.base_url}/repos/{owner}/{repo_name}/branches",
            headers=self.headers,
            params=params,
            timeout=15
        )
        response.raise_for_status()
        
        branches = response.json()
        return [b.get("name") for b in branches]
    
    def file_exists(
        self,
        owner: str,
        repo_name: str,
        file_path: str,
        branch: str = "main"
    ) -> bool:
        """
        Check if a file exists in the repository.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            file_path: Path to file in repository
            branch: Branch name
            
        Returns:
            True if file exists, False otherwise
        """
        params = {"ref": branch}
        
        response = requests.get(
            f"{self.base_url}/repos/{owner}/{repo_name}/contents/{file_path}",
            headers=self.headers,
            params=params,
            timeout=10
        )
        
        
        return response.status_code == 200
    
    def get_repository_contents(
        self,
        owner: str,
        repo_name: str,
        path: str = "",
        branch: str = "main"
    ) -> List[Dict[str, Any]]:
        """
        Get contents of a repository path.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            path: Path to directory (empty for root)
            branch: Branch name
            
        Returns:
            List of file/directory objects
        """
        params = {"ref": branch}
        
        # Ensure path doesn't start with /
        if path.startswith("/"):
            path = path[1:]
            
        url = f"{self.base_url}/repos/{owner}/{repo_name}/contents/{path}"
        
        response = requests.get(
            url,
            headers=self.headers,
            params=params,
            timeout=15
        )
        response.raise_for_status()
        
        data = response.json()
        
        # If result is a dict, it's a single file. Wrap in list.
        if isinstance(data, dict):
            return [data]
            
        # Sort: directories first, then files
        return sorted(data, key=lambda x: (x.get("type") != "dir", x.get("name").lower()))
    
    def get_commits(
        self,
        owner: str,
        repo_name: str,
        path: Optional[str] = None,
        per_page: int = 30
    ) -> List[Dict[str, Any]]:
        """
        Get commit history for a repository or specific file.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            path: Optional file path to filter commits
            per_page: Number of commits to return
            
        Returns:
            List of commit information dictionaries
        """
        params = {"per_page": per_page}
        if path:
            params["path"] = path
        
        response = requests.get(
            f"{self.base_url}/repos/{owner}/{repo_name}/commits",
            headers=self.headers,
            params=params,
            timeout=15
        )
        response.raise_for_status()
        
        commits = response.json()
        return [
            {
                "sha": c.get("sha"),
                "message": c.get("commit", {}).get("message", ""),
                "author": c.get("commit", {}).get("author", {}).get("name", "Unknown"),
                "date": c.get("commit", {}).get("author", {}).get("date", ""),
                "html_url": c.get("html_url", ""),
            }
            for c in commits
        ]
    
    def get_file_content(
        self,
        owner: str,
        repo_name: str,
        file_path: str,
        branch: str = "main",
        ref: Optional[str] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Get content of a file from the repository.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            file_path: Path to file in repository
            branch: Branch name (ignored if ref is provided)
            ref: Specific commit SHA to get file from (optional)
            
        Returns:
            Dictionary with file content and metadata, or None if not found
        """
        # Use ref (commit SHA) if provided, otherwise use branch
        params = {"ref": ref if ref else branch}
        
        response = requests.get(
            f"{self.base_url}/repos/{owner}/{repo_name}/contents/{file_path}",
            headers=self.headers,
            params=params,
            timeout=15
        )
        
        if response.status_code == 404:
            return None
        
        response.raise_for_status()
        data = response.json()
        
        # Decode content from base64
        content = None
        if data.get("content"):
            content = base64.b64decode(data["content"]).decode("utf-8")
        
        return {
            "sha": data.get("sha"),
            "content": content,
            "path": data.get("path"),
            "size": data.get("size"),
        }
    
    def create_or_update_file(
        self,
        owner: str,
        repo_name: str,
        file_path: str,
        content: str,
        commit_message: str,
        branch: str = "main"
    ) -> Dict[str, Any]:
        """
        Create or update a file in the repository.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            file_path: Path to file in repository
            content: File content (string)
            commit_message: Commit message
            branch: Branch name
            
        Returns:
            API response with commit info
        """
        # Check if file exists to get its SHA
        existing = self.get_file_content(owner, repo_name, file_path, branch)
        
        # Encode content
        content_b64 = base64.b64encode(content.encode("utf-8")).decode("utf-8")
        
        data = {
            "message": commit_message,
            "content": content_b64,
            "branch": branch
        }
        
        # If file exists, include SHA for update
        if existing and existing.get("sha"):
            data["sha"] = existing["sha"]
        
        response = requests.put(
            f"{self.base_url}/repos/{owner}/{repo_name}/contents/{file_path}",
            headers=self.headers,
            json=data,
            timeout=30
        )
        response.raise_for_status()
        
        result = response.json()
        return {
            "commit_sha": result.get("commit", {}).get("sha"),
            "content_sha": result.get("content", {}).get("sha"),
        }
    
    def create_gist(
        self,
        content: str,
        filename: str,
        description: str = "",
        is_public: bool = False
    ) -> Dict[str, Any]:
        """
        Create a GitHub Gist.
        
        Args:
            content: Content of the gist file
            filename: Name of the file in the gist
            description: Gist description
            is_public: Whether the gist is public
            
        Returns:
            Dictionary with gist URL and ID
        """
        data = {
            "description": description,
            "public": is_public,
            "files": {
                filename: {
                    "content": content
                }
            }
        }
        
        response = requests.post(
            f"{self.base_url}/gists",
            headers=self.headers,
            json=data,
            timeout=15
        )
        response.raise_for_status()
        
        result = response.json()
        return {
            "gist_id": result.get("id"),
            "gist_url": result.get("html_url"),
            "raw_url": result.get("files", {}).get(filename, {}).get("raw_url"),
        }


def create_github_service(access_token: str) -> GitHubService:
    """
    Factory function to create GitHub service instance.
    
    Args:
        access_token: GitHub OAuth access token
        
    Returns:
        GitHubService instance
    """
    return GitHubService(access_token)
