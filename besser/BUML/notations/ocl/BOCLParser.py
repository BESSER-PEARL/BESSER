# Generated from BOCL.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,88,1117,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,1,
        0,1,0,1,0,1,0,1,0,5,0,46,8,0,10,0,12,0,49,9,0,3,0,51,8,0,1,1,1,1,
        1,1,1,1,1,1,3,1,58,8,1,1,1,3,1,61,8,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,3,1,70,8,1,5,1,72,8,1,10,1,12,1,75,9,1,1,1,3,1,78,8,1,1,1,1,1,
        1,1,1,1,1,2,1,2,1,2,1,2,1,2,3,2,89,8,2,1,2,3,2,92,8,2,1,2,1,2,1,
        2,1,2,1,2,1,2,1,2,3,2,101,8,2,5,2,103,8,2,10,2,12,2,106,9,2,1,2,
        3,2,109,8,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,
        1,3,1,3,3,3,126,8,3,1,3,1,3,1,3,1,3,1,4,1,4,1,4,1,4,3,4,136,8,4,
        1,4,3,4,139,8,4,1,4,5,4,142,8,4,10,4,12,4,145,9,4,1,4,3,4,148,8,
        4,1,4,3,4,151,8,4,1,4,3,4,154,8,4,1,4,3,4,157,8,4,1,4,3,4,160,8,
        4,1,4,3,4,163,8,4,1,4,3,4,166,8,4,1,4,3,4,169,8,4,1,4,3,4,172,8,
        4,1,4,3,4,175,8,4,1,4,3,4,178,8,4,1,4,3,4,181,8,4,1,5,1,5,3,5,185,
        8,5,1,5,1,5,1,5,3,5,190,8,5,1,6,1,6,1,6,3,6,195,8,6,1,6,1,6,3,6,
        199,8,6,1,6,3,6,202,8,6,5,6,204,8,6,10,6,12,6,207,9,6,1,6,1,6,1,
        6,1,6,1,6,1,6,5,6,215,8,6,10,6,12,6,218,9,6,1,6,1,6,1,6,1,6,3,6,
        224,8,6,5,6,226,8,6,10,6,12,6,229,9,6,1,6,3,6,232,8,6,1,7,1,7,1,
        7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,243,8,7,1,8,1,8,1,8,1,8,1,8,1,8,1,
        8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,3,8,265,8,
        8,1,9,1,9,1,10,3,10,270,8,10,1,10,1,10,3,10,274,8,10,1,10,1,10,3,
        10,278,8,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,3,10,288,8,10,
        1,10,1,10,1,10,5,10,293,8,10,10,10,12,10,296,9,10,1,10,1,10,1,10,
        1,10,1,10,1,10,3,10,304,8,10,1,10,1,10,1,10,5,10,309,8,10,10,10,
        12,10,312,9,10,1,10,1,10,1,10,1,10,1,10,1,10,3,10,320,8,10,1,10,
        1,10,1,10,5,10,325,8,10,10,10,12,10,328,9,10,1,10,1,10,1,10,1,10,
        1,10,1,10,3,10,336,8,10,1,10,3,10,339,8,10,1,10,1,10,5,10,343,8,
        10,10,10,12,10,346,9,10,1,10,1,10,1,10,1,10,1,10,3,10,353,8,10,1,
        10,5,10,356,8,10,10,10,12,10,359,9,10,1,10,3,10,362,8,10,1,10,1,
        10,5,10,366,8,10,10,10,12,10,369,9,10,1,10,1,10,1,10,1,10,1,10,3,
        10,376,8,10,1,10,3,10,379,8,10,1,10,5,10,382,8,10,10,10,12,10,385,
        9,10,1,10,3,10,388,8,10,1,10,1,10,5,10,392,8,10,10,10,12,10,395,
        9,10,1,10,1,10,1,10,1,10,1,10,3,10,402,8,10,1,10,3,10,405,8,10,1,
        10,5,10,408,8,10,10,10,12,10,411,9,10,1,10,3,10,414,8,10,1,10,1,
        10,1,10,1,10,1,10,3,10,421,8,10,1,10,5,10,424,8,10,10,10,12,10,427,
        9,10,1,10,3,10,430,8,10,1,10,1,10,1,10,1,10,1,10,3,10,437,8,10,1,
        10,5,10,440,8,10,10,10,12,10,443,9,10,1,10,3,10,446,8,10,1,10,5,
        10,449,8,10,10,10,12,10,452,9,10,1,10,1,10,5,10,456,8,10,10,10,12,
        10,459,9,10,1,10,5,10,462,8,10,10,10,12,10,465,9,10,1,10,3,10,468,
        8,10,1,10,1,10,3,10,472,8,10,1,10,3,10,475,8,10,5,10,477,8,10,10,
        10,12,10,480,9,10,1,10,5,10,483,8,10,10,10,12,10,486,9,10,1,10,5,
        10,489,8,10,10,10,12,10,492,9,10,1,10,3,10,495,8,10,1,10,3,10,498,
        8,10,1,10,5,10,501,8,10,10,10,12,10,504,9,10,1,10,1,10,5,10,508,
        8,10,10,10,12,10,511,9,10,1,10,5,10,514,8,10,10,10,12,10,517,9,10,
        1,10,3,10,520,8,10,1,10,1,10,3,10,524,8,10,1,10,3,10,527,8,10,5,
        10,529,8,10,10,10,12,10,532,9,10,1,10,5,10,535,8,10,10,10,12,10,
        538,9,10,1,10,5,10,541,8,10,10,10,12,10,544,9,10,1,10,3,10,547,8,
        10,1,10,3,10,550,8,10,1,10,1,10,4,10,554,8,10,11,10,12,10,555,1,
        10,3,10,559,8,10,1,10,4,10,562,8,10,11,10,12,10,563,1,10,3,10,567,
        8,10,1,10,3,10,570,8,10,1,10,5,10,573,8,10,10,10,12,10,576,9,10,
        1,10,1,10,1,10,3,10,581,8,10,1,10,1,10,3,10,585,8,10,1,10,3,10,588,
        8,10,5,10,590,8,10,10,10,12,10,593,9,10,1,10,1,10,5,10,597,8,10,
        10,10,12,10,600,9,10,1,10,3,10,603,8,10,1,10,3,10,606,8,10,1,10,
        5,10,609,8,10,10,10,12,10,612,9,10,1,10,1,10,5,10,616,8,10,10,10,
        12,10,619,9,10,1,10,5,10,622,8,10,10,10,12,10,625,9,10,1,10,3,10,
        628,8,10,1,10,1,10,3,10,632,8,10,1,10,3,10,635,8,10,5,10,637,8,10,
        10,10,12,10,640,9,10,1,10,5,10,643,8,10,10,10,12,10,646,9,10,1,10,
        5,10,649,8,10,10,10,12,10,652,9,10,1,10,3,10,655,8,10,1,10,1,10,
        3,10,659,8,10,1,10,5,10,662,8,10,10,10,12,10,665,9,10,1,10,1,10,
        5,10,669,8,10,10,10,12,10,672,9,10,1,10,5,10,675,8,10,10,10,12,10,
        678,9,10,1,10,3,10,681,8,10,1,10,1,10,3,10,685,8,10,1,10,3,10,688,
        8,10,5,10,690,8,10,10,10,12,10,693,9,10,1,10,5,10,696,8,10,10,10,
        12,10,699,9,10,1,10,5,10,702,8,10,10,10,12,10,705,9,10,1,10,3,10,
        708,8,10,1,10,3,10,711,8,10,1,10,5,10,714,8,10,10,10,12,10,717,9,
        10,1,10,1,10,5,10,721,8,10,10,10,12,10,724,9,10,1,10,5,10,727,8,
        10,10,10,12,10,730,9,10,1,10,3,10,733,8,10,1,10,1,10,3,10,737,8,
        10,1,10,3,10,740,8,10,5,10,742,8,10,10,10,12,10,745,9,10,1,10,5,
        10,748,8,10,10,10,12,10,751,9,10,1,10,5,10,754,8,10,10,10,12,10,
        757,9,10,1,10,3,10,760,8,10,1,10,1,10,1,10,4,10,765,8,10,11,10,12,
        10,766,1,10,3,10,770,8,10,1,10,1,10,3,10,774,8,10,1,10,3,10,777,
        8,10,5,10,779,8,10,10,10,12,10,782,9,10,1,10,4,10,785,8,10,11,10,
        12,10,786,1,10,3,10,790,8,10,1,10,1,10,1,10,1,10,4,10,796,8,10,11,
        10,12,10,797,1,10,3,10,801,8,10,1,10,1,10,1,10,1,10,3,10,807,8,10,
        1,10,1,10,3,10,811,8,10,1,10,3,10,814,8,10,5,10,816,8,10,10,10,12,
        10,819,9,10,1,10,4,10,822,8,10,11,10,12,10,823,1,10,3,10,827,8,10,
        1,10,3,10,830,8,10,1,10,1,10,1,10,1,10,1,10,3,10,837,8,10,1,10,3,
        10,840,8,10,4,10,842,8,10,11,10,12,10,843,1,10,1,10,1,10,1,10,3,
        10,850,8,10,1,10,3,10,853,8,10,1,10,1,10,1,10,1,10,1,10,3,10,860,
        8,10,1,10,1,10,1,10,1,10,1,10,4,10,867,8,10,11,10,12,10,868,1,10,
        3,10,872,8,10,1,10,1,10,1,10,1,10,1,10,3,10,879,8,10,1,10,1,10,1,
        10,1,10,1,10,3,10,886,8,10,1,10,1,10,1,10,1,10,1,10,1,10,3,10,894,
        8,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,5,10,905,8,10,
        10,10,12,10,908,9,10,1,10,3,10,911,8,10,1,10,1,10,5,10,915,8,10,
        10,10,12,10,918,9,10,1,10,3,10,921,8,10,1,10,3,10,924,8,10,1,10,
        1,10,4,10,928,8,10,11,10,12,10,929,1,10,3,10,933,8,10,1,10,1,10,
        5,10,937,8,10,10,10,12,10,940,9,10,1,10,5,10,943,8,10,10,10,12,10,
        946,9,10,1,10,1,10,3,10,950,8,10,1,10,3,10,953,8,10,1,10,1,10,1,
        10,1,10,3,10,959,8,10,1,10,3,10,962,8,10,1,10,1,10,3,10,966,8,10,
        1,10,1,10,1,10,3,10,971,8,10,1,10,1,10,3,10,975,8,10,1,10,3,10,978,
        8,10,1,10,1,10,1,10,3,10,983,8,10,1,10,3,10,986,8,10,1,10,3,10,989,
        8,10,1,10,1,10,1,10,1,10,3,10,995,8,10,1,10,1,10,3,10,999,8,10,3,
        10,1001,8,10,1,11,3,11,1004,8,11,1,11,1,11,1,12,1,12,1,12,1,12,5,
        12,1012,8,12,10,12,12,12,1015,9,12,1,12,3,12,1018,8,12,1,13,1,13,
        1,13,5,13,1023,8,13,10,13,12,13,1026,9,13,1,13,1,13,3,13,1030,8,
        13,1,13,1,13,5,13,1034,8,13,10,13,12,13,1037,9,13,1,13,1,13,1,13,
        1,13,1,13,1,13,1,13,1,13,5,13,1047,8,13,10,13,12,13,1050,9,13,1,
        13,1,13,3,13,1054,8,13,1,14,1,14,1,14,1,15,1,15,1,16,1,16,3,16,1063,
        8,16,1,16,1,16,3,16,1067,8,16,1,16,3,16,1070,8,16,1,16,3,16,1073,
        8,16,3,16,1075,8,16,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,3,17,
        1085,8,17,1,18,1,18,1,19,1,19,3,19,1091,8,19,1,19,3,19,1094,8,19,
        1,19,3,19,1097,8,19,1,19,3,19,1100,8,19,1,19,3,19,1103,8,19,1,19,
        3,19,1106,8,19,1,19,3,19,1109,8,19,1,19,3,19,1112,8,19,1,19,3,19,
        1115,8,19,1,19,0,0,20,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,
        32,34,36,38,0,8,4,0,6,6,8,9,75,76,82,82,1,0,7,9,1,0,40,41,1,0,11,
        15,3,0,1,1,42,42,53,55,5,0,1,1,30,30,40,41,43,47,53,58,2,0,78,78,
        84,86,1,0,2,3,1379,0,50,1,0,0,0,2,52,1,0,0,0,4,83,1,0,0,0,6,114,
        1,0,0,0,8,131,1,0,0,0,10,182,1,0,0,0,12,231,1,0,0,0,14,242,1,0,0,
        0,16,264,1,0,0,0,18,266,1,0,0,0,20,1000,1,0,0,0,22,1003,1,0,0,0,
        24,1007,1,0,0,0,26,1029,1,0,0,0,28,1055,1,0,0,0,30,1058,1,0,0,0,
        32,1074,1,0,0,0,34,1084,1,0,0,0,36,1086,1,0,0,0,38,1088,1,0,0,0,
        40,51,3,6,3,0,41,51,3,2,1,0,42,51,3,4,2,0,43,47,3,8,4,0,44,46,3,
        20,10,0,45,44,1,0,0,0,46,49,1,0,0,0,47,45,1,0,0,0,47,48,1,0,0,0,
        48,51,1,0,0,0,49,47,1,0,0,0,50,40,1,0,0,0,50,41,1,0,0,0,50,42,1,
        0,0,0,50,43,1,0,0,0,51,1,1,0,0,0,52,53,5,5,0,0,53,54,5,83,0,0,54,
        55,5,21,0,0,55,57,5,83,0,0,56,58,5,22,0,0,57,56,1,0,0,0,57,58,1,
        0,0,0,58,73,1,0,0,0,59,61,5,83,0,0,60,59,1,0,0,0,60,61,1,0,0,0,61,
        62,1,0,0,0,62,69,5,27,0,0,63,70,5,32,0,0,64,70,5,33,0,0,65,70,5,
        34,0,0,66,70,5,35,0,0,67,70,3,16,8,0,68,70,5,49,0,0,69,63,1,0,0,
        0,69,64,1,0,0,0,69,65,1,0,0,0,69,66,1,0,0,0,69,67,1,0,0,0,69,68,
        1,0,0,0,69,70,1,0,0,0,70,72,1,0,0,0,71,60,1,0,0,0,72,75,1,0,0,0,
        73,71,1,0,0,0,73,74,1,0,0,0,74,77,1,0,0,0,75,73,1,0,0,0,76,78,5,
        23,0,0,77,76,1,0,0,0,77,78,1,0,0,0,78,79,1,0,0,0,79,80,5,8,0,0,80,
        81,5,27,0,0,81,82,3,20,10,0,82,3,1,0,0,0,83,84,5,5,0,0,84,85,5,83,
        0,0,85,86,5,21,0,0,86,88,5,83,0,0,87,89,5,22,0,0,88,87,1,0,0,0,88,
        89,1,0,0,0,89,104,1,0,0,0,90,92,5,83,0,0,91,90,1,0,0,0,91,92,1,0,
        0,0,92,93,1,0,0,0,93,100,5,27,0,0,94,101,5,32,0,0,95,101,5,33,0,
        0,96,101,5,34,0,0,97,101,5,35,0,0,98,101,3,16,8,0,99,101,5,49,0,
        0,100,94,1,0,0,0,100,95,1,0,0,0,100,96,1,0,0,0,100,97,1,0,0,0,100,
        98,1,0,0,0,100,99,1,0,0,0,100,101,1,0,0,0,101,103,1,0,0,0,102,91,
        1,0,0,0,103,106,1,0,0,0,104,102,1,0,0,0,104,105,1,0,0,0,105,108,
        1,0,0,0,106,104,1,0,0,0,107,109,5,23,0,0,108,107,1,0,0,0,108,109,
        1,0,0,0,109,110,1,0,0,0,110,111,5,9,0,0,111,112,5,27,0,0,112,113,
        3,20,10,0,113,5,1,0,0,0,114,115,5,5,0,0,115,116,5,83,0,0,116,117,
        5,21,0,0,117,118,5,83,0,0,118,125,5,27,0,0,119,126,5,32,0,0,120,
        126,5,33,0,0,121,126,5,34,0,0,122,126,5,35,0,0,123,126,3,16,8,0,
        124,126,5,49,0,0,125,119,1,0,0,0,125,120,1,0,0,0,125,121,1,0,0,0,
        125,122,1,0,0,0,125,123,1,0,0,0,125,124,1,0,0,0,126,127,1,0,0,0,
        127,128,5,6,0,0,128,129,5,27,0,0,129,130,3,20,10,0,130,7,1,0,0,0,
        131,132,5,5,0,0,132,135,5,83,0,0,133,134,5,27,0,0,134,136,3,14,7,
        0,135,133,1,0,0,0,135,136,1,0,0,0,136,138,1,0,0,0,137,139,5,24,0,
        0,138,137,1,0,0,0,138,139,1,0,0,0,139,143,1,0,0,0,140,142,3,10,5,
        0,141,140,1,0,0,0,142,145,1,0,0,0,143,141,1,0,0,0,143,144,1,0,0,
        0,144,147,1,0,0,0,145,143,1,0,0,0,146,148,5,25,0,0,147,146,1,0,0,
        0,147,148,1,0,0,0,148,150,1,0,0,0,149,151,5,21,0,0,150,149,1,0,0,
        0,150,151,1,0,0,0,151,153,1,0,0,0,152,154,3,12,6,0,153,152,1,0,0,
        0,153,154,1,0,0,0,154,156,1,0,0,0,155,157,5,27,0,0,156,155,1,0,0,
        0,156,157,1,0,0,0,157,159,1,0,0,0,158,160,3,14,7,0,159,158,1,0,0,
        0,159,160,1,0,0,0,160,162,1,0,0,0,161,163,5,22,0,0,162,161,1,0,0,
        0,162,163,1,0,0,0,163,165,1,0,0,0,164,166,5,83,0,0,165,164,1,0,0,
        0,165,166,1,0,0,0,166,168,1,0,0,0,167,169,5,23,0,0,168,167,1,0,0,
        0,168,169,1,0,0,0,169,171,1,0,0,0,170,172,5,27,0,0,171,170,1,0,0,
        0,171,172,1,0,0,0,172,174,1,0,0,0,173,175,7,0,0,0,174,173,1,0,0,
        0,174,175,1,0,0,0,175,177,1,0,0,0,176,178,5,27,0,0,177,176,1,0,0,
        0,177,178,1,0,0,0,178,180,1,0,0,0,179,181,3,20,10,0,180,179,1,0,
        0,0,180,181,1,0,0,0,181,9,1,0,0,0,182,184,7,1,0,0,183,185,5,83,0,
        0,184,183,1,0,0,0,184,185,1,0,0,0,185,186,1,0,0,0,186,187,5,27,0,
        0,187,189,3,20,10,0,188,190,5,26,0,0,189,188,1,0,0,0,189,190,1,0,
        0,0,190,11,1,0,0,0,191,192,5,83,0,0,192,205,5,22,0,0,193,195,5,31,
        0,0,194,193,1,0,0,0,194,195,1,0,0,0,195,196,1,0,0,0,196,198,3,20,
        10,0,197,199,5,31,0,0,198,197,1,0,0,0,198,199,1,0,0,0,199,201,1,
        0,0,0,200,202,5,28,0,0,201,200,1,0,0,0,201,202,1,0,0,0,202,204,1,
        0,0,0,203,194,1,0,0,0,204,207,1,0,0,0,205,203,1,0,0,0,205,206,1,
        0,0,0,206,208,1,0,0,0,207,205,1,0,0,0,208,232,5,23,0,0,209,210,5,
        83,0,0,210,216,5,22,0,0,211,212,5,83,0,0,212,213,5,27,0,0,213,215,
        5,83,0,0,214,211,1,0,0,0,215,218,1,0,0,0,216,214,1,0,0,0,216,217,
        1,0,0,0,217,219,1,0,0,0,218,216,1,0,0,0,219,232,5,23,0,0,220,227,
        5,22,0,0,221,223,5,84,0,0,222,224,5,28,0,0,223,222,1,0,0,0,223,224,
        1,0,0,0,224,226,1,0,0,0,225,221,1,0,0,0,226,229,1,0,0,0,227,225,
        1,0,0,0,227,228,1,0,0,0,228,230,1,0,0,0,229,227,1,0,0,0,230,232,
        5,23,0,0,231,191,1,0,0,0,231,209,1,0,0,0,231,220,1,0,0,0,232,13,
        1,0,0,0,233,243,5,32,0,0,234,243,5,33,0,0,235,243,5,34,0,0,236,243,
        5,35,0,0,237,243,5,16,0,0,238,243,5,17,0,0,239,243,3,16,8,0,240,
        243,3,18,9,0,241,243,5,49,0,0,242,233,1,0,0,0,242,234,1,0,0,0,242,
        235,1,0,0,0,242,236,1,0,0,0,242,237,1,0,0,0,242,238,1,0,0,0,242,
        239,1,0,0,0,242,240,1,0,0,0,242,241,1,0,0,0,243,15,1,0,0,0,244,245,
        5,49,0,0,245,246,5,44,0,0,246,247,3,14,7,0,247,248,5,46,0,0,248,
        265,1,0,0,0,249,250,5,50,0,0,250,251,5,44,0,0,251,252,3,14,7,0,252,
        253,5,46,0,0,253,265,1,0,0,0,254,255,5,51,0,0,255,256,5,44,0,0,256,
        257,3,14,7,0,257,258,5,46,0,0,258,265,1,0,0,0,259,260,5,52,0,0,260,
        261,5,44,0,0,261,262,3,14,7,0,262,263,5,46,0,0,263,265,1,0,0,0,264,
        244,1,0,0,0,264,249,1,0,0,0,264,254,1,0,0,0,264,259,1,0,0,0,265,
        17,1,0,0,0,266,267,5,83,0,0,267,19,1,0,0,0,268,270,7,2,0,0,269,268,
        1,0,0,0,269,270,1,0,0,0,270,271,1,0,0,0,271,273,3,26,13,0,272,274,
        3,20,10,0,273,272,1,0,0,0,273,274,1,0,0,0,274,1001,1,0,0,0,275,277,
        3,28,14,0,276,278,3,20,10,0,277,276,1,0,0,0,277,278,1,0,0,0,278,
        1001,1,0,0,0,279,280,5,36,0,0,280,1001,3,20,10,0,281,282,5,37,0,
        0,282,1001,3,20,10,0,283,284,5,38,0,0,284,1001,3,20,10,0,285,287,
        5,39,0,0,286,288,3,20,10,0,287,286,1,0,0,0,287,288,1,0,0,0,288,1001,
        1,0,0,0,289,294,3,34,17,0,290,291,5,29,0,0,291,293,5,83,0,0,292,
        290,1,0,0,0,293,296,1,0,0,0,294,292,1,0,0,0,294,295,1,0,0,0,295,
        297,1,0,0,0,296,294,1,0,0,0,297,298,5,29,0,0,298,299,5,60,0,0,299,
        300,5,22,0,0,300,301,3,14,7,0,301,303,5,23,0,0,302,304,3,20,10,0,
        303,302,1,0,0,0,303,304,1,0,0,0,304,1001,1,0,0,0,305,310,3,34,17,
        0,306,307,5,29,0,0,307,309,5,83,0,0,308,306,1,0,0,0,309,312,1,0,
        0,0,310,308,1,0,0,0,310,311,1,0,0,0,311,313,1,0,0,0,312,310,1,0,
        0,0,313,314,5,29,0,0,314,315,5,59,0,0,315,316,5,22,0,0,316,317,3,
        14,7,0,317,319,5,23,0,0,318,320,3,20,10,0,319,318,1,0,0,0,319,320,
        1,0,0,0,320,1001,1,0,0,0,321,326,3,34,17,0,322,323,5,29,0,0,323,
        325,5,83,0,0,324,322,1,0,0,0,325,328,1,0,0,0,326,324,1,0,0,0,326,
        327,1,0,0,0,327,329,1,0,0,0,328,326,1,0,0,0,329,330,5,29,0,0,330,
        331,5,61,0,0,331,332,5,22,0,0,332,333,3,14,7,0,333,335,5,23,0,0,
        334,336,3,20,10,0,335,334,1,0,0,0,335,336,1,0,0,0,336,1001,1,0,0,
        0,337,339,3,34,17,0,338,337,1,0,0,0,338,339,1,0,0,0,339,344,1,0,
        0,0,340,341,5,29,0,0,341,343,5,83,0,0,342,340,1,0,0,0,343,346,1,
        0,0,0,344,342,1,0,0,0,344,345,1,0,0,0,345,347,1,0,0,0,346,344,1,
        0,0,0,347,348,5,81,0,0,348,349,5,63,0,0,349,350,5,22,0,0,350,352,
        5,23,0,0,351,353,3,20,10,0,352,351,1,0,0,0,352,353,1,0,0,0,353,357,
        1,0,0,0,354,356,5,23,0,0,355,354,1,0,0,0,356,359,1,0,0,0,357,355,
        1,0,0,0,357,358,1,0,0,0,358,1001,1,0,0,0,359,357,1,0,0,0,360,362,
        3,34,17,0,361,360,1,0,0,0,361,362,1,0,0,0,362,367,1,0,0,0,363,364,
        5,29,0,0,364,366,5,83,0,0,365,363,1,0,0,0,366,369,1,0,0,0,367,365,
        1,0,0,0,367,368,1,0,0,0,368,370,1,0,0,0,369,367,1,0,0,0,370,371,
        5,81,0,0,371,372,5,64,0,0,372,373,5,22,0,0,373,375,5,23,0,0,374,
        376,3,24,12,0,375,374,1,0,0,0,375,376,1,0,0,0,376,378,1,0,0,0,377,
        379,3,20,10,0,378,377,1,0,0,0,378,379,1,0,0,0,379,383,1,0,0,0,380,
        382,5,23,0,0,381,380,1,0,0,0,382,385,1,0,0,0,383,381,1,0,0,0,383,
        384,1,0,0,0,384,1001,1,0,0,0,385,383,1,0,0,0,386,388,3,34,17,0,387,
        386,1,0,0,0,387,388,1,0,0,0,388,393,1,0,0,0,389,390,5,29,0,0,390,
        392,5,83,0,0,391,389,1,0,0,0,392,395,1,0,0,0,393,391,1,0,0,0,393,
        394,1,0,0,0,394,396,1,0,0,0,395,393,1,0,0,0,396,397,5,81,0,0,397,
        398,5,65,0,0,398,399,5,22,0,0,399,401,5,23,0,0,400,402,3,24,12,0,
        401,400,1,0,0,0,401,402,1,0,0,0,402,404,1,0,0,0,403,405,3,20,10,
        0,404,403,1,0,0,0,404,405,1,0,0,0,405,409,1,0,0,0,406,408,5,23,0,
        0,407,406,1,0,0,0,408,411,1,0,0,0,409,407,1,0,0,0,409,410,1,0,0,
        0,410,1001,1,0,0,0,411,409,1,0,0,0,412,414,5,81,0,0,413,412,1,0,
        0,0,413,414,1,0,0,0,414,415,1,0,0,0,415,416,5,66,0,0,416,417,5,22,
        0,0,417,418,3,20,10,0,418,420,5,23,0,0,419,421,3,20,10,0,420,419,
        1,0,0,0,420,421,1,0,0,0,421,425,1,0,0,0,422,424,5,23,0,0,423,422,
        1,0,0,0,424,427,1,0,0,0,425,423,1,0,0,0,425,426,1,0,0,0,426,1001,
        1,0,0,0,427,425,1,0,0,0,428,430,5,81,0,0,429,428,1,0,0,0,429,430,
        1,0,0,0,430,431,1,0,0,0,431,432,5,67,0,0,432,433,5,22,0,0,433,434,
        3,20,10,0,434,436,5,23,0,0,435,437,3,20,10,0,436,435,1,0,0,0,436,
        437,1,0,0,0,437,441,1,0,0,0,438,440,5,23,0,0,439,438,1,0,0,0,440,
        443,1,0,0,0,441,439,1,0,0,0,441,442,1,0,0,0,442,1001,1,0,0,0,443,
        441,1,0,0,0,444,446,5,81,0,0,445,444,1,0,0,0,445,446,1,0,0,0,446,
        450,1,0,0,0,447,449,5,22,0,0,448,447,1,0,0,0,449,452,1,0,0,0,450,
        448,1,0,0,0,450,451,1,0,0,0,451,453,1,0,0,0,452,450,1,0,0,0,453,
        457,5,51,0,0,454,456,5,24,0,0,455,454,1,0,0,0,456,459,1,0,0,0,457,
        455,1,0,0,0,457,458,1,0,0,0,458,463,1,0,0,0,459,457,1,0,0,0,460,
        462,5,22,0,0,461,460,1,0,0,0,462,465,1,0,0,0,463,461,1,0,0,0,463,
        464,1,0,0,0,464,478,1,0,0,0,465,463,1,0,0,0,466,468,5,31,0,0,467,
        466,1,0,0,0,467,468,1,0,0,0,468,469,1,0,0,0,469,471,3,20,10,0,470,
        472,5,31,0,0,471,470,1,0,0,0,471,472,1,0,0,0,472,474,1,0,0,0,473,
        475,5,28,0,0,474,473,1,0,0,0,474,475,1,0,0,0,475,477,1,0,0,0,476,
        467,1,0,0,0,477,480,1,0,0,0,478,476,1,0,0,0,478,479,1,0,0,0,479,
        484,1,0,0,0,480,478,1,0,0,0,481,483,5,25,0,0,482,481,1,0,0,0,483,
        486,1,0,0,0,484,482,1,0,0,0,484,485,1,0,0,0,485,490,1,0,0,0,486,
        484,1,0,0,0,487,489,5,23,0,0,488,487,1,0,0,0,489,492,1,0,0,0,490,
        488,1,0,0,0,490,491,1,0,0,0,491,494,1,0,0,0,492,490,1,0,0,0,493,
        495,3,20,10,0,494,493,1,0,0,0,494,495,1,0,0,0,495,1001,1,0,0,0,496,
        498,5,81,0,0,497,496,1,0,0,0,497,498,1,0,0,0,498,502,1,0,0,0,499,
        501,5,22,0,0,500,499,1,0,0,0,501,504,1,0,0,0,502,500,1,0,0,0,502,
        503,1,0,0,0,503,505,1,0,0,0,504,502,1,0,0,0,505,509,5,68,0,0,506,
        508,5,24,0,0,507,506,1,0,0,0,508,511,1,0,0,0,509,507,1,0,0,0,509,
        510,1,0,0,0,510,515,1,0,0,0,511,509,1,0,0,0,512,514,5,22,0,0,513,
        512,1,0,0,0,514,517,1,0,0,0,515,513,1,0,0,0,515,516,1,0,0,0,516,
        530,1,0,0,0,517,515,1,0,0,0,518,520,5,31,0,0,519,518,1,0,0,0,519,
        520,1,0,0,0,520,521,1,0,0,0,521,523,3,20,10,0,522,524,5,31,0,0,523,
        522,1,0,0,0,523,524,1,0,0,0,524,526,1,0,0,0,525,527,5,28,0,0,526,
        525,1,0,0,0,526,527,1,0,0,0,527,529,1,0,0,0,528,519,1,0,0,0,529,
        532,1,0,0,0,530,528,1,0,0,0,530,531,1,0,0,0,531,536,1,0,0,0,532,
        530,1,0,0,0,533,535,5,23,0,0,534,533,1,0,0,0,535,538,1,0,0,0,536,
        534,1,0,0,0,536,537,1,0,0,0,537,542,1,0,0,0,538,536,1,0,0,0,539,
        541,5,25,0,0,540,539,1,0,0,0,541,544,1,0,0,0,542,540,1,0,0,0,542,
        543,1,0,0,0,543,546,1,0,0,0,544,542,1,0,0,0,545,547,3,20,10,0,546,
        545,1,0,0,0,546,547,1,0,0,0,547,1001,1,0,0,0,548,550,5,81,0,0,549,
        548,1,0,0,0,549,550,1,0,0,0,550,551,1,0,0,0,551,553,5,62,0,0,552,
        554,5,22,0,0,553,552,1,0,0,0,554,555,1,0,0,0,555,553,1,0,0,0,555,
        556,1,0,0,0,556,558,1,0,0,0,557,559,3,20,10,0,558,557,1,0,0,0,558,
        559,1,0,0,0,559,561,1,0,0,0,560,562,5,23,0,0,561,560,1,0,0,0,562,
        563,1,0,0,0,563,561,1,0,0,0,563,564,1,0,0,0,564,566,1,0,0,0,565,
        567,3,20,10,0,566,565,1,0,0,0,566,567,1,0,0,0,567,1001,1,0,0,0,568,
        570,5,81,0,0,569,568,1,0,0,0,569,570,1,0,0,0,570,574,1,0,0,0,571,
        573,5,22,0,0,572,571,1,0,0,0,573,576,1,0,0,0,574,572,1,0,0,0,574,
        575,1,0,0,0,575,577,1,0,0,0,576,574,1,0,0,0,577,578,5,52,0,0,578,
        591,5,24,0,0,579,581,5,31,0,0,580,579,1,0,0,0,580,581,1,0,0,0,581,
        582,1,0,0,0,582,584,3,20,10,0,583,585,5,31,0,0,584,583,1,0,0,0,584,
        585,1,0,0,0,585,587,1,0,0,0,586,588,5,28,0,0,587,586,1,0,0,0,587,
        588,1,0,0,0,588,590,1,0,0,0,589,580,1,0,0,0,590,593,1,0,0,0,591,
        589,1,0,0,0,591,592,1,0,0,0,592,594,1,0,0,0,593,591,1,0,0,0,594,
        598,5,25,0,0,595,597,5,23,0,0,596,595,1,0,0,0,597,600,1,0,0,0,598,
        596,1,0,0,0,598,599,1,0,0,0,599,602,1,0,0,0,600,598,1,0,0,0,601,
        603,3,20,10,0,602,601,1,0,0,0,602,603,1,0,0,0,603,1001,1,0,0,0,604,
        606,5,81,0,0,605,604,1,0,0,0,605,606,1,0,0,0,606,610,1,0,0,0,607,
        609,5,22,0,0,608,607,1,0,0,0,609,612,1,0,0,0,610,608,1,0,0,0,610,
        611,1,0,0,0,611,613,1,0,0,0,612,610,1,0,0,0,613,617,5,69,0,0,614,
        616,5,24,0,0,615,614,1,0,0,0,616,619,1,0,0,0,617,615,1,0,0,0,617,
        618,1,0,0,0,618,623,1,0,0,0,619,617,1,0,0,0,620,622,5,22,0,0,621,
        620,1,0,0,0,622,625,1,0,0,0,623,621,1,0,0,0,623,624,1,0,0,0,624,
        638,1,0,0,0,625,623,1,0,0,0,626,628,5,31,0,0,627,626,1,0,0,0,627,
        628,1,0,0,0,628,629,1,0,0,0,629,631,3,20,10,0,630,632,5,31,0,0,631,
        630,1,0,0,0,631,632,1,0,0,0,632,634,1,0,0,0,633,635,5,28,0,0,634,
        633,1,0,0,0,634,635,1,0,0,0,635,637,1,0,0,0,636,627,1,0,0,0,637,
        640,1,0,0,0,638,636,1,0,0,0,638,639,1,0,0,0,639,644,1,0,0,0,640,
        638,1,0,0,0,641,643,5,25,0,0,642,641,1,0,0,0,643,646,1,0,0,0,644,
        642,1,0,0,0,644,645,1,0,0,0,645,650,1,0,0,0,646,644,1,0,0,0,647,
        649,5,23,0,0,648,647,1,0,0,0,649,652,1,0,0,0,650,648,1,0,0,0,650,
        651,1,0,0,0,651,654,1,0,0,0,652,650,1,0,0,0,653,655,3,20,10,0,654,
        653,1,0,0,0,654,655,1,0,0,0,655,656,1,0,0,0,656,1001,5,23,0,0,657,
        659,5,81,0,0,658,657,1,0,0,0,658,659,1,0,0,0,659,663,1,0,0,0,660,
        662,5,22,0,0,661,660,1,0,0,0,662,665,1,0,0,0,663,661,1,0,0,0,663,
        664,1,0,0,0,664,666,1,0,0,0,665,663,1,0,0,0,666,670,5,49,0,0,667,
        669,5,22,0,0,668,667,1,0,0,0,669,672,1,0,0,0,670,668,1,0,0,0,670,
        671,1,0,0,0,671,676,1,0,0,0,672,670,1,0,0,0,673,675,5,24,0,0,674,
        673,1,0,0,0,675,678,1,0,0,0,676,674,1,0,0,0,676,677,1,0,0,0,677,
        691,1,0,0,0,678,676,1,0,0,0,679,681,5,31,0,0,680,679,1,0,0,0,680,
        681,1,0,0,0,681,682,1,0,0,0,682,684,3,20,10,0,683,685,5,31,0,0,684,
        683,1,0,0,0,684,685,1,0,0,0,685,687,1,0,0,0,686,688,5,28,0,0,687,
        686,1,0,0,0,687,688,1,0,0,0,688,690,1,0,0,0,689,680,1,0,0,0,690,
        693,1,0,0,0,691,689,1,0,0,0,691,692,1,0,0,0,692,697,1,0,0,0,693,
        691,1,0,0,0,694,696,5,25,0,0,695,694,1,0,0,0,696,699,1,0,0,0,697,
        695,1,0,0,0,697,698,1,0,0,0,698,703,1,0,0,0,699,697,1,0,0,0,700,
        702,5,23,0,0,701,700,1,0,0,0,702,705,1,0,0,0,703,701,1,0,0,0,703,
        704,1,0,0,0,704,707,1,0,0,0,705,703,1,0,0,0,706,708,3,20,10,0,707,
        706,1,0,0,0,707,708,1,0,0,0,708,1001,1,0,0,0,709,711,5,81,0,0,710,
        709,1,0,0,0,710,711,1,0,0,0,711,715,1,0,0,0,712,714,5,22,0,0,713,
        712,1,0,0,0,714,717,1,0,0,0,715,713,1,0,0,0,715,716,1,0,0,0,716,
        718,1,0,0,0,717,715,1,0,0,0,718,722,5,50,0,0,719,721,5,22,0,0,720,
        719,1,0,0,0,721,724,1,0,0,0,722,720,1,0,0,0,722,723,1,0,0,0,723,
        728,1,0,0,0,724,722,1,0,0,0,725,727,5,24,0,0,726,725,1,0,0,0,727,
        730,1,0,0,0,728,726,1,0,0,0,728,729,1,0,0,0,729,743,1,0,0,0,730,
        728,1,0,0,0,731,733,5,31,0,0,732,731,1,0,0,0,732,733,1,0,0,0,733,
        734,1,0,0,0,734,736,3,20,10,0,735,737,5,31,0,0,736,735,1,0,0,0,736,
        737,1,0,0,0,737,739,1,0,0,0,738,740,5,28,0,0,739,738,1,0,0,0,739,
        740,1,0,0,0,740,742,1,0,0,0,741,732,1,0,0,0,742,745,1,0,0,0,743,
        741,1,0,0,0,743,744,1,0,0,0,744,749,1,0,0,0,745,743,1,0,0,0,746,
        748,5,25,0,0,747,746,1,0,0,0,748,751,1,0,0,0,749,747,1,0,0,0,749,
        750,1,0,0,0,750,755,1,0,0,0,751,749,1,0,0,0,752,754,5,23,0,0,753,
        752,1,0,0,0,754,757,1,0,0,0,755,753,1,0,0,0,755,756,1,0,0,0,756,
        759,1,0,0,0,757,755,1,0,0,0,758,760,3,20,10,0,759,758,1,0,0,0,759,
        760,1,0,0,0,760,1001,1,0,0,0,761,762,5,81,0,0,762,764,5,70,0,0,763,
        765,5,22,0,0,764,763,1,0,0,0,765,766,1,0,0,0,766,764,1,0,0,0,766,
        767,1,0,0,0,767,780,1,0,0,0,768,770,5,31,0,0,769,768,1,0,0,0,769,
        770,1,0,0,0,770,771,1,0,0,0,771,773,3,20,10,0,772,774,5,31,0,0,773,
        772,1,0,0,0,773,774,1,0,0,0,774,776,1,0,0,0,775,777,5,28,0,0,776,
        775,1,0,0,0,776,777,1,0,0,0,777,779,1,0,0,0,778,769,1,0,0,0,779,
        782,1,0,0,0,780,778,1,0,0,0,780,781,1,0,0,0,781,784,1,0,0,0,782,
        780,1,0,0,0,783,785,5,23,0,0,784,783,1,0,0,0,785,786,1,0,0,0,786,
        784,1,0,0,0,786,787,1,0,0,0,787,789,1,0,0,0,788,790,3,20,10,0,789,
        788,1,0,0,0,789,790,1,0,0,0,790,1001,1,0,0,0,791,792,5,81,0,0,792,
        793,5,71,0,0,793,795,5,22,0,0,794,796,5,23,0,0,795,794,1,0,0,0,796,
        797,1,0,0,0,797,795,1,0,0,0,797,798,1,0,0,0,798,800,1,0,0,0,799,
        801,3,20,10,0,800,799,1,0,0,0,800,801,1,0,0,0,801,1001,1,0,0,0,802,
        803,5,81,0,0,803,804,5,72,0,0,804,817,5,22,0,0,805,807,5,31,0,0,
        806,805,1,0,0,0,806,807,1,0,0,0,807,808,1,0,0,0,808,810,3,20,10,
        0,809,811,5,31,0,0,810,809,1,0,0,0,810,811,1,0,0,0,811,813,1,0,0,
        0,812,814,5,28,0,0,813,812,1,0,0,0,813,814,1,0,0,0,814,816,1,0,0,
        0,815,806,1,0,0,0,816,819,1,0,0,0,817,815,1,0,0,0,817,818,1,0,0,
        0,818,821,1,0,0,0,819,817,1,0,0,0,820,822,5,23,0,0,821,820,1,0,0,
        0,822,823,1,0,0,0,823,821,1,0,0,0,823,824,1,0,0,0,824,826,1,0,0,
        0,825,827,3,20,10,0,826,825,1,0,0,0,826,827,1,0,0,0,827,1001,1,0,
        0,0,828,830,5,81,0,0,829,828,1,0,0,0,829,830,1,0,0,0,830,831,1,0,
        0,0,831,832,7,3,0,0,832,841,5,22,0,0,833,836,5,83,0,0,834,835,5,
        27,0,0,835,837,5,83,0,0,836,834,1,0,0,0,836,837,1,0,0,0,837,839,
        1,0,0,0,838,840,5,28,0,0,839,838,1,0,0,0,839,840,1,0,0,0,840,842,
        1,0,0,0,841,833,1,0,0,0,842,843,1,0,0,0,843,841,1,0,0,0,843,844,
        1,0,0,0,844,845,1,0,0,0,845,846,5,48,0,0,846,847,3,20,10,0,847,849,
        5,23,0,0,848,850,3,22,11,0,849,848,1,0,0,0,849,850,1,0,0,0,850,1001,
        1,0,0,0,851,853,5,81,0,0,852,851,1,0,0,0,852,853,1,0,0,0,853,854,
        1,0,0,0,854,855,7,3,0,0,855,856,5,22,0,0,856,857,3,20,10,0,857,859,
        5,23,0,0,858,860,3,22,11,0,859,858,1,0,0,0,859,860,1,0,0,0,860,1001,
        1,0,0,0,861,862,5,81,0,0,862,863,5,73,0,0,863,864,5,22,0,0,864,866,
        3,20,10,0,865,867,5,23,0,0,866,865,1,0,0,0,867,868,1,0,0,0,868,866,
        1,0,0,0,868,869,1,0,0,0,869,871,1,0,0,0,870,872,3,20,10,0,871,870,
        1,0,0,0,871,872,1,0,0,0,872,1001,1,0,0,0,873,874,5,81,0,0,874,875,
        5,74,0,0,875,876,5,22,0,0,876,878,5,23,0,0,877,879,3,20,10,0,878,
        877,1,0,0,0,878,879,1,0,0,0,879,1001,1,0,0,0,880,881,5,81,0,0,881,
        882,5,75,0,0,882,883,5,22,0,0,883,885,5,23,0,0,884,886,3,20,10,0,
        885,884,1,0,0,0,885,886,1,0,0,0,886,1001,1,0,0,0,887,888,5,81,0,
        0,888,889,5,77,0,0,889,890,5,22,0,0,890,891,3,20,10,0,891,893,5,
        23,0,0,892,894,3,20,10,0,893,892,1,0,0,0,893,894,1,0,0,0,894,1001,
        1,0,0,0,895,896,5,82,0,0,896,897,5,27,0,0,897,1001,3,20,10,0,898,
        899,5,83,0,0,899,900,5,27,0,0,900,901,5,83,0,0,901,902,5,30,0,0,
        902,1001,3,20,10,0,903,905,5,22,0,0,904,903,1,0,0,0,905,908,1,0,
        0,0,906,904,1,0,0,0,906,907,1,0,0,0,907,910,1,0,0,0,908,906,1,0,
        0,0,909,911,3,34,17,0,910,909,1,0,0,0,910,911,1,0,0,0,911,916,1,
        0,0,0,912,913,5,29,0,0,913,915,5,83,0,0,914,912,1,0,0,0,915,918,
        1,0,0,0,916,914,1,0,0,0,916,917,1,0,0,0,917,920,1,0,0,0,918,916,
        1,0,0,0,919,921,3,30,15,0,920,919,1,0,0,0,920,921,1,0,0,0,921,923,
        1,0,0,0,922,924,3,34,17,0,923,922,1,0,0,0,923,924,1,0,0,0,924,927,
        1,0,0,0,925,926,5,29,0,0,926,928,5,83,0,0,927,925,1,0,0,0,928,929,
        1,0,0,0,929,927,1,0,0,0,929,930,1,0,0,0,930,932,1,0,0,0,931,933,
        3,20,10,0,932,931,1,0,0,0,932,933,1,0,0,0,933,1001,1,0,0,0,934,938,
        3,34,17,0,935,937,5,29,0,0,936,935,1,0,0,0,937,940,1,0,0,0,938,936,
        1,0,0,0,938,939,1,0,0,0,939,944,1,0,0,0,940,938,1,0,0,0,941,943,
        5,83,0,0,942,941,1,0,0,0,943,946,1,0,0,0,944,942,1,0,0,0,944,945,
        1,0,0,0,945,947,1,0,0,0,946,944,1,0,0,0,947,949,3,12,6,0,948,950,
        3,30,15,0,949,948,1,0,0,0,949,950,1,0,0,0,950,952,1,0,0,0,951,953,
        3,20,10,0,952,951,1,0,0,0,952,953,1,0,0,0,953,1001,1,0,0,0,954,955,
        5,81,0,0,955,1001,3,20,10,0,956,958,5,84,0,0,957,959,3,20,10,0,958,
        957,1,0,0,0,958,959,1,0,0,0,959,1001,1,0,0,0,960,962,5,81,0,0,961,
        960,1,0,0,0,961,962,1,0,0,0,962,963,1,0,0,0,963,965,3,12,6,0,964,
        966,3,20,10,0,965,964,1,0,0,0,965,966,1,0,0,0,966,1001,1,0,0,0,967,
        968,5,31,0,0,968,970,3,20,10,0,969,971,5,29,0,0,970,969,1,0,0,0,
        970,971,1,0,0,0,971,972,1,0,0,0,972,974,5,31,0,0,973,975,5,29,0,
        0,974,973,1,0,0,0,974,975,1,0,0,0,975,977,1,0,0,0,976,978,3,20,10,
        0,977,976,1,0,0,0,977,978,1,0,0,0,978,1001,1,0,0,0,979,980,5,20,
        0,0,980,1001,3,20,10,0,981,983,5,40,0,0,982,981,1,0,0,0,982,983,
        1,0,0,0,983,985,1,0,0,0,984,986,5,41,0,0,985,984,1,0,0,0,985,986,
        1,0,0,0,986,988,1,0,0,0,987,989,5,83,0,0,988,987,1,0,0,0,988,989,
        1,0,0,0,989,990,1,0,0,0,990,991,5,21,0,0,991,1001,3,20,10,0,992,
        994,3,30,15,0,993,995,3,32,16,0,994,993,1,0,0,0,994,995,1,0,0,0,
        995,1001,1,0,0,0,996,998,3,34,17,0,997,999,3,20,10,0,998,997,1,0,
        0,0,998,999,1,0,0,0,999,1001,1,0,0,0,1000,269,1,0,0,0,1000,275,1,
        0,0,0,1000,279,1,0,0,0,1000,281,1,0,0,0,1000,283,1,0,0,0,1000,285,
        1,0,0,0,1000,289,1,0,0,0,1000,305,1,0,0,0,1000,321,1,0,0,0,1000,
        338,1,0,0,0,1000,361,1,0,0,0,1000,387,1,0,0,0,1000,413,1,0,0,0,1000,
        429,1,0,0,0,1000,445,1,0,0,0,1000,497,1,0,0,0,1000,549,1,0,0,0,1000,
        569,1,0,0,0,1000,605,1,0,0,0,1000,658,1,0,0,0,1000,710,1,0,0,0,1000,
        761,1,0,0,0,1000,791,1,0,0,0,1000,802,1,0,0,0,1000,829,1,0,0,0,1000,
        852,1,0,0,0,1000,861,1,0,0,0,1000,873,1,0,0,0,1000,880,1,0,0,0,1000,
        887,1,0,0,0,1000,895,1,0,0,0,1000,898,1,0,0,0,1000,906,1,0,0,0,1000,
        934,1,0,0,0,1000,954,1,0,0,0,1000,956,1,0,0,0,1000,961,1,0,0,0,1000,
        967,1,0,0,0,1000,979,1,0,0,0,1000,982,1,0,0,0,1000,992,1,0,0,0,1000,
        996,1,0,0,0,1001,21,1,0,0,0,1002,1004,7,2,0,0,1003,1002,1,0,0,0,
        1003,1004,1,0,0,0,1004,1005,1,0,0,0,1005,1006,3,20,10,0,1006,23,
        1,0,0,0,1007,1017,3,30,15,0,1008,1013,3,34,17,0,1009,1010,5,29,0,
        0,1010,1012,5,83,0,0,1011,1009,1,0,0,0,1012,1015,1,0,0,0,1013,1011,
        1,0,0,0,1013,1014,1,0,0,0,1014,1018,1,0,0,0,1015,1013,1,0,0,0,1016,
        1018,5,84,0,0,1017,1008,1,0,0,0,1017,1016,1,0,0,0,1018,25,1,0,0,
        0,1019,1024,3,34,17,0,1020,1021,5,29,0,0,1021,1023,5,83,0,0,1022,
        1020,1,0,0,0,1023,1026,1,0,0,0,1024,1022,1,0,0,0,1024,1025,1,0,0,
        0,1025,1030,1,0,0,0,1026,1024,1,0,0,0,1027,1030,5,84,0,0,1028,1030,
        3,38,19,0,1029,1019,1,0,0,0,1029,1027,1,0,0,0,1029,1028,1,0,0,0,
        1030,1035,1,0,0,0,1031,1032,5,29,0,0,1032,1034,5,83,0,0,1033,1031,
        1,0,0,0,1034,1037,1,0,0,0,1035,1033,1,0,0,0,1035,1036,1,0,0,0,1036,
        1038,1,0,0,0,1037,1035,1,0,0,0,1038,1053,3,30,15,0,1039,1040,3,34,
        17,0,1040,1041,5,21,0,0,1041,1042,5,83,0,0,1042,1054,1,0,0,0,1043,
        1048,3,34,17,0,1044,1045,5,29,0,0,1045,1047,5,83,0,0,1046,1044,1,
        0,0,0,1047,1050,1,0,0,0,1048,1046,1,0,0,0,1048,1049,1,0,0,0,1049,
        1054,1,0,0,0,1050,1048,1,0,0,0,1051,1054,5,84,0,0,1052,1054,3,38,
        19,0,1053,1039,1,0,0,0,1053,1043,1,0,0,0,1053,1051,1,0,0,0,1053,
        1052,1,0,0,0,1054,27,1,0,0,0,1055,1056,7,4,0,0,1056,1057,3,20,10,
        0,1057,29,1,0,0,0,1058,1059,7,5,0,0,1059,31,1,0,0,0,1060,1075,5,
        84,0,0,1061,1063,5,31,0,0,1062,1061,1,0,0,0,1062,1063,1,0,0,0,1063,
        1064,1,0,0,0,1064,1066,5,83,0,0,1065,1067,5,22,0,0,1066,1065,1,0,
        0,0,1066,1067,1,0,0,0,1067,1069,1,0,0,0,1068,1070,5,23,0,0,1069,
        1068,1,0,0,0,1069,1070,1,0,0,0,1070,1072,1,0,0,0,1071,1073,5,31,
        0,0,1072,1071,1,0,0,0,1072,1073,1,0,0,0,1073,1075,1,0,0,0,1074,1060,
        1,0,0,0,1074,1062,1,0,0,0,1075,33,1,0,0,0,1076,1085,3,36,18,0,1077,
        1085,5,10,0,0,1078,1085,3,12,6,0,1079,1080,5,22,0,0,1080,1081,3,
        20,10,0,1081,1082,5,23,0,0,1082,1085,1,0,0,0,1083,1085,5,83,0,0,
        1084,1076,1,0,0,0,1084,1077,1,0,0,0,1084,1078,1,0,0,0,1084,1079,
        1,0,0,0,1084,1083,1,0,0,0,1085,35,1,0,0,0,1086,1087,7,6,0,0,1087,
        37,1,0,0,0,1088,1090,5,18,0,0,1089,1091,5,21,0,0,1090,1089,1,0,0,
        0,1090,1091,1,0,0,0,1091,1093,1,0,0,0,1092,1094,7,7,0,0,1093,1092,
        1,0,0,0,1093,1094,1,0,0,0,1094,1096,1,0,0,0,1095,1097,5,22,0,0,1096,
        1095,1,0,0,0,1096,1097,1,0,0,0,1097,1099,1,0,0,0,1098,1100,5,23,
        0,0,1099,1098,1,0,0,0,1099,1100,1,0,0,0,1100,1102,1,0,0,0,1101,1103,
        5,29,0,0,1102,1101,1,0,0,0,1102,1103,1,0,0,0,1103,1105,1,0,0,0,1104,
        1106,5,4,0,0,1105,1104,1,0,0,0,1105,1106,1,0,0,0,1106,1108,1,0,0,
        0,1107,1109,5,22,0,0,1108,1107,1,0,0,0,1108,1109,1,0,0,0,1109,1111,
        1,0,0,0,1110,1112,5,84,0,0,1111,1110,1,0,0,0,1111,1112,1,0,0,0,1112,
        1114,1,0,0,0,1113,1115,5,23,0,0,1114,1113,1,0,0,0,1114,1115,1,0,
        0,0,1115,39,1,0,0,0,211,47,50,57,60,69,73,77,88,91,100,104,108,125,
        135,138,143,147,150,153,156,159,162,165,168,171,174,177,180,184,
        189,194,198,201,205,216,223,227,231,242,264,269,273,277,287,294,
        303,310,319,326,335,338,344,352,357,361,367,375,378,383,387,393,
        401,404,409,413,420,425,429,436,441,445,450,457,463,467,471,474,
        478,484,490,494,497,502,509,515,519,523,526,530,536,542,546,549,
        555,558,563,566,569,574,580,584,587,591,598,602,605,610,617,623,
        627,631,634,638,644,650,654,658,663,670,676,680,684,687,691,697,
        703,707,710,715,722,728,732,736,739,743,749,755,759,766,769,773,
        776,780,786,789,797,800,806,810,813,817,823,826,829,836,839,843,
        849,852,859,868,871,878,885,893,906,910,916,920,923,929,932,938,
        944,949,952,958,961,965,970,974,977,982,985,988,994,998,1000,1003,
        1013,1017,1024,1029,1035,1048,1053,1062,1066,1069,1072,1074,1084,
        1090,1093,1096,1099,1102,1105,1108,1111,1114
    ]

class BOCLParser ( Parser ):

    grammarFileName = "BOCL.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'*'", "'now'", "'today'", "'addDays'", 
                     "'context'", "'init'", "'inv'", "'pre'", "'post'", 
                     "'self'", "'forAll'", "'exists'", "'select'", "'reject'", 
                     "'collect'", "'OclAny'", "'OclVoid'", "<INVALID>", 
                     "<INVALID>", "'..'", "'::'", "'('", "')'", "'{'", "'}'", 
                     "';'", "':'", "','", "'.'", "'='", "'''", "'Boolean'", 
                     "'Integer'", "'Real'", "<INVALID>", "'if'", "'then'", 
                     "'else'", "'endif'", "'and'", "'or'", "'not'", "'<>'", 
                     "'<'", "'<='", "'>'", "'>='", "'|'", "<INVALID>", "'Bag'", 
                     "'Sequence'", "'OrderedSet'", "'-'", "'+'", "'/'", 
                     "' '", "'xor'", "'implies'", "'oclAsType'", "'oclIsTypeOf'", 
                     "'oclIsKindOf'", "'allInstances'", "'isEmpty'", "'sum'", 
                     "'size'", "'includes'", "'excludes'", "'subSequence'", 
                     "'subOrderedSet'", "'prepend'", "'last'", "'append'", 
                     "'symmetricDifference'", "'first'", "'derive'", "'body'", 
                     "'union'", "'null'", "'let'", "'in'", "<INVALID>", 
                     "'def'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "CONTEXT", "INIT", "INV", "PRE", "POST", 
                      "SELF", "FORALL", "EXISTS", "SELECT", "REJECT", "COLLECT", 
                      "OCLANY", "OCLVOID", "DATE", "WS", "DoubleDots", "DoubleCOLON", 
                      "LPAREN", "RPAREN", "LBRACE", "RBRACE", "SEMI", "COLON", 
                      "COMMA", "DOT", "EQUAL", "SingleQuote", "BOOLEAN_TYPE", 
                      "INTEGER_TYPE", "REAL_TYPE", "STRING_TYPE", "IF", 
                      "THEN", "ELSE", "ENDIF", "AND", "OR", "NOT", "NOTEQUAL", 
                      "LT", "LE", "GT", "GE", "PIPE", "SET", "BAG", "SEQUENCE", 
                      "ORDEREDSET", "MINUS", "PLUS", "Divide", "EMPTYSTRING", 
                      "XOR", "IMPLIES", "OCLASTYPE", "OCLISTYPEOF", "OCLISKINDOF", 
                      "ALLINSTANCES", "ISEMPTY", "SUM", "SIZE", "INCLUDES", 
                      "EXCLUDES", "SUBSEQUENCE", "SUBORDEREDSET", "PREPEND", 
                      "LAST", "APPEND", "SYMMETRICDIFFERENCE", "FIRST", 
                      "DERIVE", "BODY", "UNION", "NULL", "LET", "IN", "Arrow", 
                      "Def", "ID", "NUMBER", "STRING_LITERAL", "BOOLEAN_LITERAL", 
                      "COMMENT", "LINE_COMMENT" ]

    RULE_oclFile = 0
    RULE_preCondition = 1
    RULE_postCondition = 2
    RULE_initConstraints = 3
    RULE_contextDeclaration = 4
    RULE_constraint = 5
    RULE_functionCall = 6
    RULE_type = 7
    RULE_collectionType = 8
    RULE_userDefinedType = 9
    RULE_expression = 10
    RULE_endExpression = 11
    RULE_binaryFunctionCall = 12
    RULE_binaryExpression = 13
    RULE_unaryExpression = 14
    RULE_operator = 15
    RULE_numberORUserDefined = 16
    RULE_primaryExpression = 17
    RULE_literal = 18
    RULE_dateLiteral = 19

    ruleNames =  [ "oclFile", "preCondition", "postCondition", "initConstraints", 
                   "contextDeclaration", "constraint", "functionCall", "type", 
                   "collectionType", "userDefinedType", "expression", "endExpression", 
                   "binaryFunctionCall", "binaryExpression", "unaryExpression", 
                   "operator", "numberORUserDefined", "primaryExpression", 
                   "literal", "dateLiteral" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    CONTEXT=5
    INIT=6
    INV=7
    PRE=8
    POST=9
    SELF=10
    FORALL=11
    EXISTS=12
    SELECT=13
    REJECT=14
    COLLECT=15
    OCLANY=16
    OCLVOID=17
    DATE=18
    WS=19
    DoubleDots=20
    DoubleCOLON=21
    LPAREN=22
    RPAREN=23
    LBRACE=24
    RBRACE=25
    SEMI=26
    COLON=27
    COMMA=28
    DOT=29
    EQUAL=30
    SingleQuote=31
    BOOLEAN_TYPE=32
    INTEGER_TYPE=33
    REAL_TYPE=34
    STRING_TYPE=35
    IF=36
    THEN=37
    ELSE=38
    ENDIF=39
    AND=40
    OR=41
    NOT=42
    NOTEQUAL=43
    LT=44
    LE=45
    GT=46
    GE=47
    PIPE=48
    SET=49
    BAG=50
    SEQUENCE=51
    ORDEREDSET=52
    MINUS=53
    PLUS=54
    Divide=55
    EMPTYSTRING=56
    XOR=57
    IMPLIES=58
    OCLASTYPE=59
    OCLISTYPEOF=60
    OCLISKINDOF=61
    ALLINSTANCES=62
    ISEMPTY=63
    SUM=64
    SIZE=65
    INCLUDES=66
    EXCLUDES=67
    SUBSEQUENCE=68
    SUBORDEREDSET=69
    PREPEND=70
    LAST=71
    APPEND=72
    SYMMETRICDIFFERENCE=73
    FIRST=74
    DERIVE=75
    BODY=76
    UNION=77
    NULL=78
    LET=79
    IN=80
    Arrow=81
    Def=82
    ID=83
    NUMBER=84
    STRING_LITERAL=85
    BOOLEAN_LITERAL=86
    COMMENT=87
    LINE_COMMENT=88

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class OclFileContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def initConstraints(self):
            return self.getTypedRuleContext(BOCLParser.InitConstraintsContext,0)


        def preCondition(self):
            return self.getTypedRuleContext(BOCLParser.PreConditionContext,0)


        def postCondition(self):
            return self.getTypedRuleContext(BOCLParser.PostConditionContext,0)


        def contextDeclaration(self):
            return self.getTypedRuleContext(BOCLParser.ContextDeclarationContext,0)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)


        def getRuleIndex(self):
            return BOCLParser.RULE_oclFile

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOclFile" ):
                listener.enterOclFile(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOclFile" ):
                listener.exitOclFile(self)




    def oclFile(self):

        localctx = BOCLParser.OclFileContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_oclFile)
        self._la = 0 # Token type
        try:
            self.state = 50
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 40
                self.initConstraints()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 41
                self.preCondition()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 42
                self.postCondition()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 43
                self.contextDeclaration()
                self.state = 47
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & 5187865230800387074) != 0) or ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 2068495) != 0):
                    self.state = 44
                    self.expression()
                    self.state = 49
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PreConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONTEXT(self):
            return self.getToken(BOCLParser.CONTEXT, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)

        def DoubleCOLON(self):
            return self.getToken(BOCLParser.DoubleCOLON, 0)

        def PRE(self):
            return self.getToken(BOCLParser.PRE, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COLON)
            else:
                return self.getToken(BOCLParser.COLON, i)

        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(BOCLParser.RPAREN, 0)

        def BOOLEAN_TYPE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.BOOLEAN_TYPE)
            else:
                return self.getToken(BOCLParser.BOOLEAN_TYPE, i)

        def INTEGER_TYPE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.INTEGER_TYPE)
            else:
                return self.getToken(BOCLParser.INTEGER_TYPE, i)

        def REAL_TYPE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.REAL_TYPE)
            else:
                return self.getToken(BOCLParser.REAL_TYPE, i)

        def STRING_TYPE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.STRING_TYPE)
            else:
                return self.getToken(BOCLParser.STRING_TYPE, i)

        def collectionType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.CollectionTypeContext)
            else:
                return self.getTypedRuleContext(BOCLParser.CollectionTypeContext,i)


        def SET(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.SET)
            else:
                return self.getToken(BOCLParser.SET, i)

        def getRuleIndex(self):
            return BOCLParser.RULE_preCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreCondition" ):
                listener.enterPreCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreCondition" ):
                listener.exitPreCondition(self)




    def preCondition(self):

        localctx = BOCLParser.PreConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_preCondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 52
            self.match(BOCLParser.CONTEXT)
            self.state = 53
            self.match(BOCLParser.ID)
            self.state = 54
            self.match(BOCLParser.DoubleCOLON)
            self.state = 55
            self.match(BOCLParser.ID)
            self.state = 57
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==22:
                self.state = 56
                self.match(BOCLParser.LPAREN)


            self.state = 73
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==27 or _la==83:
                self.state = 60
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==83:
                    self.state = 59
                    self.match(BOCLParser.ID)


                self.state = 62
                self.match(BOCLParser.COLON)
                self.state = 69
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
                if la_ == 1:
                    self.state = 63
                    self.match(BOCLParser.BOOLEAN_TYPE)

                elif la_ == 2:
                    self.state = 64
                    self.match(BOCLParser.INTEGER_TYPE)

                elif la_ == 3:
                    self.state = 65
                    self.match(BOCLParser.REAL_TYPE)

                elif la_ == 4:
                    self.state = 66
                    self.match(BOCLParser.STRING_TYPE)

                elif la_ == 5:
                    self.state = 67
                    self.collectionType()

                elif la_ == 6:
                    self.state = 68
                    self.match(BOCLParser.SET)


                self.state = 75
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 77
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==23:
                self.state = 76
                self.match(BOCLParser.RPAREN)


            self.state = 79
            self.match(BOCLParser.PRE)
            self.state = 80
            self.match(BOCLParser.COLON)
            self.state = 81
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PostConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONTEXT(self):
            return self.getToken(BOCLParser.CONTEXT, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)

        def DoubleCOLON(self):
            return self.getToken(BOCLParser.DoubleCOLON, 0)

        def POST(self):
            return self.getToken(BOCLParser.POST, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COLON)
            else:
                return self.getToken(BOCLParser.COLON, i)

        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(BOCLParser.RPAREN, 0)

        def BOOLEAN_TYPE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.BOOLEAN_TYPE)
            else:
                return self.getToken(BOCLParser.BOOLEAN_TYPE, i)

        def INTEGER_TYPE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.INTEGER_TYPE)
            else:
                return self.getToken(BOCLParser.INTEGER_TYPE, i)

        def REAL_TYPE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.REAL_TYPE)
            else:
                return self.getToken(BOCLParser.REAL_TYPE, i)

        def STRING_TYPE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.STRING_TYPE)
            else:
                return self.getToken(BOCLParser.STRING_TYPE, i)

        def collectionType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.CollectionTypeContext)
            else:
                return self.getTypedRuleContext(BOCLParser.CollectionTypeContext,i)


        def SET(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.SET)
            else:
                return self.getToken(BOCLParser.SET, i)

        def getRuleIndex(self):
            return BOCLParser.RULE_postCondition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPostCondition" ):
                listener.enterPostCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPostCondition" ):
                listener.exitPostCondition(self)




    def postCondition(self):

        localctx = BOCLParser.PostConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_postCondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            self.match(BOCLParser.CONTEXT)
            self.state = 84
            self.match(BOCLParser.ID)
            self.state = 85
            self.match(BOCLParser.DoubleCOLON)
            self.state = 86
            self.match(BOCLParser.ID)
            self.state = 88
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==22:
                self.state = 87
                self.match(BOCLParser.LPAREN)


            self.state = 104
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==27 or _la==83:
                self.state = 91
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==83:
                    self.state = 90
                    self.match(BOCLParser.ID)


                self.state = 93
                self.match(BOCLParser.COLON)
                self.state = 100
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
                if la_ == 1:
                    self.state = 94
                    self.match(BOCLParser.BOOLEAN_TYPE)

                elif la_ == 2:
                    self.state = 95
                    self.match(BOCLParser.INTEGER_TYPE)

                elif la_ == 3:
                    self.state = 96
                    self.match(BOCLParser.REAL_TYPE)

                elif la_ == 4:
                    self.state = 97
                    self.match(BOCLParser.STRING_TYPE)

                elif la_ == 5:
                    self.state = 98
                    self.collectionType()

                elif la_ == 6:
                    self.state = 99
                    self.match(BOCLParser.SET)


                self.state = 106
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 108
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==23:
                self.state = 107
                self.match(BOCLParser.RPAREN)


            self.state = 110
            self.match(BOCLParser.POST)
            self.state = 111
            self.match(BOCLParser.COLON)
            self.state = 112
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InitConstraintsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONTEXT(self):
            return self.getToken(BOCLParser.CONTEXT, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)

        def DoubleCOLON(self):
            return self.getToken(BOCLParser.DoubleCOLON, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COLON)
            else:
                return self.getToken(BOCLParser.COLON, i)

        def INIT(self):
            return self.getToken(BOCLParser.INIT, 0)

        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def BOOLEAN_TYPE(self):
            return self.getToken(BOCLParser.BOOLEAN_TYPE, 0)

        def INTEGER_TYPE(self):
            return self.getToken(BOCLParser.INTEGER_TYPE, 0)

        def REAL_TYPE(self):
            return self.getToken(BOCLParser.REAL_TYPE, 0)

        def STRING_TYPE(self):
            return self.getToken(BOCLParser.STRING_TYPE, 0)

        def collectionType(self):
            return self.getTypedRuleContext(BOCLParser.CollectionTypeContext,0)


        def SET(self):
            return self.getToken(BOCLParser.SET, 0)

        def getRuleIndex(self):
            return BOCLParser.RULE_initConstraints

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitConstraints" ):
                listener.enterInitConstraints(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitConstraints" ):
                listener.exitInitConstraints(self)




    def initConstraints(self):

        localctx = BOCLParser.InitConstraintsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_initConstraints)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114
            self.match(BOCLParser.CONTEXT)
            self.state = 115
            self.match(BOCLParser.ID)
            self.state = 116
            self.match(BOCLParser.DoubleCOLON)
            self.state = 117
            self.match(BOCLParser.ID)
            self.state = 118
            self.match(BOCLParser.COLON)
            self.state = 125
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.state = 119
                self.match(BOCLParser.BOOLEAN_TYPE)
                pass

            elif la_ == 2:
                self.state = 120
                self.match(BOCLParser.INTEGER_TYPE)
                pass

            elif la_ == 3:
                self.state = 121
                self.match(BOCLParser.REAL_TYPE)
                pass

            elif la_ == 4:
                self.state = 122
                self.match(BOCLParser.STRING_TYPE)
                pass

            elif la_ == 5:
                self.state = 123
                self.collectionType()
                pass

            elif la_ == 6:
                self.state = 124
                self.match(BOCLParser.SET)
                pass


            self.state = 127
            self.match(BOCLParser.INIT)
            self.state = 128
            self.match(BOCLParser.COLON)
            self.state = 129
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContextDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return BOCLParser.RULE_contextDeclaration

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ContextExpContext(ContextDeclarationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ContextDeclarationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONTEXT(self):
            return self.getToken(BOCLParser.CONTEXT, 0)
        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)
        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COLON)
            else:
                return self.getToken(BOCLParser.COLON, i)
        def type_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.TypeContext)
            else:
                return self.getTypedRuleContext(BOCLParser.TypeContext,i)

        def LBRACE(self):
            return self.getToken(BOCLParser.LBRACE, 0)
        def constraint(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ConstraintContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ConstraintContext,i)

        def RBRACE(self):
            return self.getToken(BOCLParser.RBRACE, 0)
        def DoubleCOLON(self):
            return self.getToken(BOCLParser.DoubleCOLON, 0)
        def functionCall(self):
            return self.getTypedRuleContext(BOCLParser.FunctionCallContext,0)

        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(BOCLParser.RPAREN, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)

        def DERIVE(self):
            return self.getToken(BOCLParser.DERIVE, 0)
        def BODY(self):
            return self.getToken(BOCLParser.BODY, 0)
        def INIT(self):
            return self.getToken(BOCLParser.INIT, 0)
        def PRE(self):
            return self.getToken(BOCLParser.PRE, 0)
        def POST(self):
            return self.getToken(BOCLParser.POST, 0)
        def Def(self):
            return self.getToken(BOCLParser.Def, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContextExp" ):
                listener.enterContextExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContextExp" ):
                listener.exitContextExp(self)



    def contextDeclaration(self):

        localctx = BOCLParser.ContextDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_contextDeclaration)
        self._la = 0 # Token type
        try:
            localctx = BOCLParser.ContextExpContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            self.match(BOCLParser.CONTEXT)
            self.state = 132
            self.match(BOCLParser.ID)
            self.state = 135
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.state = 133
                self.match(BOCLParser.COLON)
                self.state = 134
                self.type_()


            self.state = 138
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==24:
                self.state = 137
                self.match(BOCLParser.LBRACE)


            self.state = 143
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 140
                    self.constraint() 
                self.state = 145
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,15,self._ctx)

            self.state = 147
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==25:
                self.state = 146
                self.match(BOCLParser.RBRACE)


            self.state = 150
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.state = 149
                self.match(BOCLParser.DoubleCOLON)


            self.state = 153
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.state = 152
                self.functionCall()


            self.state = 156
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.state = 155
                self.match(BOCLParser.COLON)


            self.state = 159
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.state = 158
                self.type_()


            self.state = 162
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.state = 161
                self.match(BOCLParser.LPAREN)


            self.state = 165
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.state = 164
                self.match(BOCLParser.ID)


            self.state = 168
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==23:
                self.state = 167
                self.match(BOCLParser.RPAREN)


            self.state = 171
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
            if la_ == 1:
                self.state = 170
                self.match(BOCLParser.COLON)


            self.state = 174
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.state = 173
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 832) != 0) or ((((_la - 75)) & ~0x3f) == 0 and ((1 << (_la - 75)) & 131) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 177
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==27:
                self.state = 176
                self.match(BOCLParser.COLON)


            self.state = 180
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.state = 179
                self.expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COLON(self):
            return self.getToken(BOCLParser.COLON, 0)

        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def INV(self):
            return self.getToken(BOCLParser.INV, 0)

        def PRE(self):
            return self.getToken(BOCLParser.PRE, 0)

        def POST(self):
            return self.getToken(BOCLParser.POST, 0)

        def ID(self):
            return self.getToken(BOCLParser.ID, 0)

        def SEMI(self):
            return self.getToken(BOCLParser.SEMI, 0)

        def getRuleIndex(self):
            return BOCLParser.RULE_constraint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstraint" ):
                listener.enterConstraint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstraint" ):
                listener.exitConstraint(self)




    def constraint(self):

        localctx = BOCLParser.ConstraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_constraint)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 896) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 184
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==83:
                self.state = 183
                self.match(BOCLParser.ID)


            self.state = 186
            self.match(BOCLParser.COLON)
            self.state = 187
            self.expression()
            self.state = 189
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==26:
                self.state = 188
                self.match(BOCLParser.SEMI)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)

        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(BOCLParser.RPAREN, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)


        def SingleQuote(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.SingleQuote)
            else:
                return self.getToken(BOCLParser.SingleQuote, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COMMA)
            else:
                return self.getToken(BOCLParser.COMMA, i)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COLON)
            else:
                return self.getToken(BOCLParser.COLON, i)

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.NUMBER)
            else:
                return self.getToken(BOCLParser.NUMBER, i)

        def getRuleIndex(self):
            return BOCLParser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)




    def functionCall(self):

        localctx = BOCLParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_functionCall)
        self._la = 0 # Token type
        try:
            self.state = 231
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 191
                self.match(BOCLParser.ID)
                self.state = 192
                self.match(BOCLParser.LPAREN)
                self.state = 205
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & 5187865230800387074) != 0) or ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 2068495) != 0):
                    self.state = 194
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
                    if la_ == 1:
                        self.state = 193
                        self.match(BOCLParser.SingleQuote)


                    self.state = 196
                    self.expression()
                    self.state = 198
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
                    if la_ == 1:
                        self.state = 197
                        self.match(BOCLParser.SingleQuote)


                    self.state = 201
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==28:
                        self.state = 200
                        self.match(BOCLParser.COMMA)


                    self.state = 207
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 208
                self.match(BOCLParser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 209
                self.match(BOCLParser.ID)
                self.state = 210
                self.match(BOCLParser.LPAREN)
                self.state = 216
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==83:
                    self.state = 211
                    self.match(BOCLParser.ID)
                    self.state = 212
                    self.match(BOCLParser.COLON)
                    self.state = 213
                    self.match(BOCLParser.ID)
                    self.state = 218
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 219
                self.match(BOCLParser.RPAREN)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 220
                self.match(BOCLParser.LPAREN)
                self.state = 227
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==84:
                    self.state = 221
                    self.match(BOCLParser.NUMBER)
                    self.state = 223
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==28:
                        self.state = 222
                        self.match(BOCLParser.COMMA)


                    self.state = 229
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 230
                self.match(BOCLParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOLEAN_TYPE(self):
            return self.getToken(BOCLParser.BOOLEAN_TYPE, 0)

        def INTEGER_TYPE(self):
            return self.getToken(BOCLParser.INTEGER_TYPE, 0)

        def REAL_TYPE(self):
            return self.getToken(BOCLParser.REAL_TYPE, 0)

        def STRING_TYPE(self):
            return self.getToken(BOCLParser.STRING_TYPE, 0)

        def OCLANY(self):
            return self.getToken(BOCLParser.OCLANY, 0)

        def OCLVOID(self):
            return self.getToken(BOCLParser.OCLVOID, 0)

        def collectionType(self):
            return self.getTypedRuleContext(BOCLParser.CollectionTypeContext,0)


        def userDefinedType(self):
            return self.getTypedRuleContext(BOCLParser.UserDefinedTypeContext,0)


        def SET(self):
            return self.getToken(BOCLParser.SET, 0)

        def getRuleIndex(self):
            return BOCLParser.RULE_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType" ):
                listener.enterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType" ):
                listener.exitType(self)




    def type_(self):

        localctx = BOCLParser.TypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_type)
        try:
            self.state = 242
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 233
                self.match(BOCLParser.BOOLEAN_TYPE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 234
                self.match(BOCLParser.INTEGER_TYPE)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 235
                self.match(BOCLParser.REAL_TYPE)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 236
                self.match(BOCLParser.STRING_TYPE)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 237
                self.match(BOCLParser.OCLANY)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 238
                self.match(BOCLParser.OCLVOID)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 239
                self.collectionType()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 240
                self.userDefinedType()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 241
                self.match(BOCLParser.SET)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CollectionTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(BOCLParser.SET, 0)

        def LT(self):
            return self.getToken(BOCLParser.LT, 0)

        def type_(self):
            return self.getTypedRuleContext(BOCLParser.TypeContext,0)


        def GT(self):
            return self.getToken(BOCLParser.GT, 0)

        def BAG(self):
            return self.getToken(BOCLParser.BAG, 0)

        def SEQUENCE(self):
            return self.getToken(BOCLParser.SEQUENCE, 0)

        def ORDEREDSET(self):
            return self.getToken(BOCLParser.ORDEREDSET, 0)

        def getRuleIndex(self):
            return BOCLParser.RULE_collectionType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollectionType" ):
                listener.enterCollectionType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollectionType" ):
                listener.exitCollectionType(self)




    def collectionType(self):

        localctx = BOCLParser.CollectionTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_collectionType)
        try:
            self.state = 264
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [49]:
                self.enterOuterAlt(localctx, 1)
                self.state = 244
                self.match(BOCLParser.SET)
                self.state = 245
                self.match(BOCLParser.LT)
                self.state = 246
                self.type_()
                self.state = 247
                self.match(BOCLParser.GT)
                pass
            elif token in [50]:
                self.enterOuterAlt(localctx, 2)
                self.state = 249
                self.match(BOCLParser.BAG)
                self.state = 250
                self.match(BOCLParser.LT)
                self.state = 251
                self.type_()
                self.state = 252
                self.match(BOCLParser.GT)
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 3)
                self.state = 254
                self.match(BOCLParser.SEQUENCE)
                self.state = 255
                self.match(BOCLParser.LT)
                self.state = 256
                self.type_()
                self.state = 257
                self.match(BOCLParser.GT)
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 4)
                self.state = 259
                self.match(BOCLParser.ORDEREDSET)
                self.state = 260
                self.match(BOCLParser.LT)
                self.state = 261
                self.type_()
                self.state = 262
                self.match(BOCLParser.GT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UserDefinedTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(BOCLParser.ID, 0)

        def getRuleIndex(self):
            return BOCLParser.RULE_userDefinedType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUserDefinedType" ):
                listener.enterUserDefinedType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUserDefinedType" ):
                listener.exitUserDefinedType(self)




    def userDefinedType(self):

        localctx = BOCLParser.UserDefinedTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_userDefinedType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 266
            self.match(BOCLParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return BOCLParser.RULE_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ElseExpContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ELSE(self):
            return self.getToken(BOCLParser.ELSE, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElseExp" ):
                listener.enterElseExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElseExp" ):
                listener.exitElseExp(self)


    class ArrowexpContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrowexp" ):
                listener.enterArrowexp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrowexp" ):
                listener.exitArrowexp(self)


    class COLLECTIONContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def PIPE(self):
            return self.getToken(BOCLParser.PIPE, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)

        def RPAREN(self):
            return self.getToken(BOCLParser.RPAREN, 0)
        def FORALL(self):
            return self.getToken(BOCLParser.FORALL, 0)
        def EXISTS(self):
            return self.getToken(BOCLParser.EXISTS, 0)
        def SELECT(self):
            return self.getToken(BOCLParser.SELECT, 0)
        def REJECT(self):
            return self.getToken(BOCLParser.REJECT, 0)
        def COLLECT(self):
            return self.getToken(BOCLParser.COLLECT, 0)
        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)
        def endExpression(self):
            return self.getTypedRuleContext(BOCLParser.EndExpressionContext,0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COLON)
            else:
                return self.getToken(BOCLParser.COLON, i)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COMMA)
            else:
                return self.getToken(BOCLParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCOLLECTION" ):
                listener.enterCOLLECTION(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCOLLECTION" ):
                listener.exitCOLLECTION(self)


    class SETContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SET(self):
            return self.getToken(BOCLParser.SET, 0)
        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.LPAREN)
            else:
                return self.getToken(BOCLParser.LPAREN, i)
        def LBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.LBRACE)
            else:
                return self.getToken(BOCLParser.LBRACE, i)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)

        def RBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RBRACE)
            else:
                return self.getToken(BOCLParser.RBRACE, i)
        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)
        def SingleQuote(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.SingleQuote)
            else:
                return self.getToken(BOCLParser.SingleQuote, i)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COMMA)
            else:
                return self.getToken(BOCLParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSET" ):
                listener.enterSET(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSET" ):
                listener.exitSET(self)


    class DefIDAssignmentexpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)
        def COLON(self):
            return self.getToken(BOCLParser.COLON, 0)
        def EQUAL(self):
            return self.getToken(BOCLParser.EQUAL, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefIDAssignmentexpression" ):
                listener.enterDefIDAssignmentexpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefIDAssignmentexpression" ):
                listener.exitDefIDAssignmentexpression(self)


    class PredefinedfunctionCallContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def functionCall(self):
            return self.getTypedRuleContext(BOCLParser.FunctionCallContext,0)

        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredefinedfunctionCall" ):
                listener.enterPredefinedfunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredefinedfunctionCall" ):
                listener.exitPredefinedfunctionCall(self)


    class UnaryContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unaryExpression(self):
            return self.getTypedRuleContext(BOCLParser.UnaryExpressionContext,0)

        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnary" ):
                listener.enterUnary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnary" ):
                listener.exitUnary(self)


    class INCLUDESContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INCLUDES(self):
            return self.getToken(BOCLParser.INCLUDES, 0)
        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)

        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)
        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterINCLUDES" ):
                listener.enterINCLUDES(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitINCLUDES" ):
                listener.exitINCLUDES(self)


    class ThenExpContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def THEN(self):
            return self.getToken(BOCLParser.THEN, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThenExp" ):
                listener.enterThenExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThenExp" ):
                listener.exitThenExp(self)


    class SUBORDEREDSETContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SUBORDEREDSET(self):
            return self.getToken(BOCLParser.SUBORDEREDSET, 0)
        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)
        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.LPAREN)
            else:
                return self.getToken(BOCLParser.LPAREN, i)
        def LBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.LBRACE)
            else:
                return self.getToken(BOCLParser.LBRACE, i)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)

        def RBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RBRACE)
            else:
                return self.getToken(BOCLParser.RBRACE, i)
        def SingleQuote(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.SingleQuote)
            else:
                return self.getToken(BOCLParser.SingleQuote, i)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COMMA)
            else:
                return self.getToken(BOCLParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSUBORDEREDSET" ):
                listener.enterSUBORDEREDSET(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSUBORDEREDSET" ):
                listener.exitSUBORDEREDSET(self)


    class PrimaryExpContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.LPAREN)
            else:
                return self.getToken(BOCLParser.LPAREN, i)
        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.PrimaryExpressionContext,i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.DOT)
            else:
                return self.getToken(BOCLParser.DOT, i)
        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)
        def operator(self):
            return self.getTypedRuleContext(BOCLParser.OperatorContext,0)

        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryExp" ):
                listener.enterPrimaryExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryExp" ):
                listener.exitPrimaryExp(self)


    class OCLISKINDOFContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(BOCLParser.PrimaryExpressionContext,0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.DOT)
            else:
                return self.getToken(BOCLParser.DOT, i)
        def OCLISKINDOF(self):
            return self.getToken(BOCLParser.OCLISKINDOF, 0)
        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def type_(self):
            return self.getTypedRuleContext(BOCLParser.TypeContext,0)

        def RPAREN(self):
            return self.getToken(BOCLParser.RPAREN, 0)
        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOCLISKINDOF" ):
                listener.enterOCLISKINDOF(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOCLISKINDOF" ):
                listener.exitOCLISKINDOF(self)


    class NumberContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(BOCLParser.NUMBER, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)


    class DoubleCOLONsContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DoubleCOLON(self):
            return self.getToken(BOCLParser.DoubleCOLON, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)

        def AND(self):
            return self.getToken(BOCLParser.AND, 0)
        def OR(self):
            return self.getToken(BOCLParser.OR, 0)
        def ID(self):
            return self.getToken(BOCLParser.ID, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoubleCOLONs" ):
                listener.enterDoubleCOLONs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoubleCOLONs" ):
                listener.exitDoubleCOLONs(self)


    class SYMMETRICDIFFERENCEContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def SYMMETRICDIFFERENCE(self):
            return self.getToken(BOCLParser.SYMMETRICDIFFERENCE, 0)
        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)

        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSYMMETRICDIFFERENCE" ):
                listener.enterSYMMETRICDIFFERENCE(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSYMMETRICDIFFERENCE" ):
                listener.exitSYMMETRICDIFFERENCE(self)


    class SEQUENCEContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SEQUENCE(self):
            return self.getToken(BOCLParser.SEQUENCE, 0)
        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.LPAREN)
            else:
                return self.getToken(BOCLParser.LPAREN, i)
        def LBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.LBRACE)
            else:
                return self.getToken(BOCLParser.LBRACE, i)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)

        def RBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RBRACE)
            else:
                return self.getToken(BOCLParser.RBRACE, i)
        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)
        def SingleQuote(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.SingleQuote)
            else:
                return self.getToken(BOCLParser.SingleQuote, i)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COMMA)
            else:
                return self.getToken(BOCLParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSEQUENCE" ):
                listener.enterSEQUENCE(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSEQUENCE" ):
                listener.exitSEQUENCE(self)


    class ORDEREDSETContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ORDEREDSET(self):
            return self.getToken(BOCLParser.ORDEREDSET, 0)
        def LBRACE(self):
            return self.getToken(BOCLParser.LBRACE, 0)
        def RBRACE(self):
            return self.getToken(BOCLParser.RBRACE, 0)
        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.LPAREN)
            else:
                return self.getToken(BOCLParser.LPAREN, i)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)

        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)
        def SingleQuote(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.SingleQuote)
            else:
                return self.getToken(BOCLParser.SingleQuote, i)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COMMA)
            else:
                return self.getToken(BOCLParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterORDEREDSET" ):
                listener.enterORDEREDSET(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitORDEREDSET" ):
                listener.exitORDEREDSET(self)


    class DoubleDotsContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DoubleDots(self):
            return self.getToken(BOCLParser.DoubleDots, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoubleDots" ):
                listener.enterDoubleDots(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoubleDots" ):
                listener.exitDoubleDots(self)


    class EXCLUDESContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EXCLUDES(self):
            return self.getToken(BOCLParser.EXCLUDES, 0)
        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)

        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)
        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEXCLUDES" ):
                listener.enterEXCLUDES(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEXCLUDES" ):
                listener.exitEXCLUDES(self)


    class DERIVEContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def DERIVE(self):
            return self.getToken(BOCLParser.DERIVE, 0)
        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(BOCLParser.RPAREN, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDERIVE" ):
                listener.enterDERIVE(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDERIVE" ):
                listener.exitDERIVE(self)


    class IDContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(BOCLParser.PrimaryExpressionContext,0)

        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterID" ):
                listener.enterID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitID" ):
                listener.exitID(self)


    class ALLINSTANCESContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ALLINSTANCES(self):
            return self.getToken(BOCLParser.ALLINSTANCES, 0)
        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.LPAREN)
            else:
                return self.getToken(BOCLParser.LPAREN, i)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)

        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterALLINSTANCES" ):
                listener.enterALLINSTANCES(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitALLINSTANCES" ):
                listener.exitALLINSTANCES(self)


    class OpContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def operator(self):
            return self.getTypedRuleContext(BOCLParser.OperatorContext,0)

        def numberORUserDefined(self):
            return self.getTypedRuleContext(BOCLParser.NumberORUserDefinedContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOp" ):
                listener.enterOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOp" ):
                listener.exitOp(self)


    class SUBSEQUENCEContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SUBSEQUENCE(self):
            return self.getToken(BOCLParser.SUBSEQUENCE, 0)
        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.LPAREN)
            else:
                return self.getToken(BOCLParser.LPAREN, i)
        def LBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.LBRACE)
            else:
                return self.getToken(BOCLParser.LBRACE, i)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)

        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)
        def RBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RBRACE)
            else:
                return self.getToken(BOCLParser.RBRACE, i)
        def SingleQuote(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.SingleQuote)
            else:
                return self.getToken(BOCLParser.SingleQuote, i)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COMMA)
            else:
                return self.getToken(BOCLParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSUBSEQUENCE" ):
                listener.enterSUBSEQUENCE(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSUBSEQUENCE" ):
                listener.exitSUBSEQUENCE(self)


    class SIZEContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def SIZE(self):
            return self.getToken(BOCLParser.SIZE, 0)
        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)
        def primaryExpression(self):
            return self.getTypedRuleContext(BOCLParser.PrimaryExpressionContext,0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.DOT)
            else:
                return self.getToken(BOCLParser.DOT, i)
        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)
        def binaryFunctionCall(self):
            return self.getTypedRuleContext(BOCLParser.BinaryFunctionCallContext,0)

        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSIZE" ):
                listener.enterSIZE(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSIZE" ):
                listener.exitSIZE(self)


    class SingleQuoteExpContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SingleQuote(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.SingleQuote)
            else:
                return self.getToken(BOCLParser.SingleQuote, i)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.DOT)
            else:
                return self.getToken(BOCLParser.DOT, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleQuoteExp" ):
                listener.enterSingleQuoteExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleQuoteExp" ):
                listener.exitSingleQuoteExp(self)


    class BAGContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BAG(self):
            return self.getToken(BOCLParser.BAG, 0)
        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.LPAREN)
            else:
                return self.getToken(BOCLParser.LPAREN, i)
        def LBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.LBRACE)
            else:
                return self.getToken(BOCLParser.LBRACE, i)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)

        def RBRACE(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RBRACE)
            else:
                return self.getToken(BOCLParser.RBRACE, i)
        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)
        def SingleQuote(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.SingleQuote)
            else:
                return self.getToken(BOCLParser.SingleQuote, i)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COMMA)
            else:
                return self.getToken(BOCLParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBAG" ):
                listener.enterBAG(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBAG" ):
                listener.exitBAG(self)


    class OCLISTYPEOFContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(BOCLParser.PrimaryExpressionContext,0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.DOT)
            else:
                return self.getToken(BOCLParser.DOT, i)
        def OCLISTYPEOF(self):
            return self.getToken(BOCLParser.OCLISTYPEOF, 0)
        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def type_(self):
            return self.getTypedRuleContext(BOCLParser.TypeContext,0)

        def RPAREN(self):
            return self.getToken(BOCLParser.RPAREN, 0)
        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOCLISTYPEOF" ):
                listener.enterOCLISTYPEOF(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOCLISTYPEOF" ):
                listener.exitOCLISTYPEOF(self)


    class SUMContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def SUM(self):
            return self.getToken(BOCLParser.SUM, 0)
        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)
        def primaryExpression(self):
            return self.getTypedRuleContext(BOCLParser.PrimaryExpressionContext,0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.DOT)
            else:
                return self.getToken(BOCLParser.DOT, i)
        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)
        def binaryFunctionCall(self):
            return self.getTypedRuleContext(BOCLParser.BinaryFunctionCallContext,0)

        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSUM" ):
                listener.enterSUM(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSUM" ):
                listener.exitSUM(self)


    class FIRSTContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def FIRST(self):
            return self.getToken(BOCLParser.FIRST, 0)
        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(BOCLParser.RPAREN, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFIRST" ):
                listener.enterFIRST(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFIRST" ):
                listener.exitFIRST(self)


    class APPENDContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def APPEND(self):
            return self.getToken(BOCLParser.APPEND, 0)
        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)

        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)
        def SingleQuote(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.SingleQuote)
            else:
                return self.getToken(BOCLParser.SingleQuote, i)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COMMA)
            else:
                return self.getToken(BOCLParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAPPEND" ):
                listener.enterAPPEND(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAPPEND" ):
                listener.exitAPPEND(self)


    class OCLASTYPEContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(BOCLParser.PrimaryExpressionContext,0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.DOT)
            else:
                return self.getToken(BOCLParser.DOT, i)
        def OCLASTYPE(self):
            return self.getToken(BOCLParser.OCLASTYPE, 0)
        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def type_(self):
            return self.getTypedRuleContext(BOCLParser.TypeContext,0)

        def RPAREN(self):
            return self.getToken(BOCLParser.RPAREN, 0)
        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOCLASTYPE" ):
                listener.enterOCLASTYPE(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOCLASTYPE" ):
                listener.exitOCLASTYPE(self)


    class CollectionExpressionVariableContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)

        def RPAREN(self):
            return self.getToken(BOCLParser.RPAREN, 0)
        def FORALL(self):
            return self.getToken(BOCLParser.FORALL, 0)
        def EXISTS(self):
            return self.getToken(BOCLParser.EXISTS, 0)
        def SELECT(self):
            return self.getToken(BOCLParser.SELECT, 0)
        def REJECT(self):
            return self.getToken(BOCLParser.REJECT, 0)
        def COLLECT(self):
            return self.getToken(BOCLParser.COLLECT, 0)
        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def endExpression(self):
            return self.getTypedRuleContext(BOCLParser.EndExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollectionExpressionVariable" ):
                listener.enterCollectionExpressionVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollectionExpressionVariable" ):
                listener.exitCollectionExpressionVariable(self)


    class LASTContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def LAST(self):
            return self.getToken(BOCLParser.LAST, 0)
        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLAST" ):
                listener.enterLAST(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLAST" ):
                listener.exitLAST(self)


    class BinaryContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def binaryExpression(self):
            return self.getTypedRuleContext(BOCLParser.BinaryExpressionContext,0)

        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)

        def AND(self):
            return self.getToken(BOCLParser.AND, 0)
        def OR(self):
            return self.getToken(BOCLParser.OR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinary" ):
                listener.enterBinary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinary" ):
                listener.exitBinary(self)


    class IfExpContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IF(self):
            return self.getToken(BOCLParser.IF, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfExp" ):
                listener.enterIfExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfExp" ):
                listener.exitIfExp(self)


    class EndIfExpContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ENDIF(self):
            return self.getToken(BOCLParser.ENDIF, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndIfExp" ):
                listener.enterEndIfExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndIfExp" ):
                listener.exitEndIfExp(self)


    class ISEMPTYContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def ISEMPTY(self):
            return self.getToken(BOCLParser.ISEMPTY, 0)
        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)
        def primaryExpression(self):
            return self.getTypedRuleContext(BOCLParser.PrimaryExpressionContext,0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.DOT)
            else:
                return self.getToken(BOCLParser.DOT, i)
        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterISEMPTY" ):
                listener.enterISEMPTY(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitISEMPTY" ):
                listener.exitISEMPTY(self)


    class DefExpContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Def(self):
            return self.getToken(BOCLParser.Def, 0)
        def COLON(self):
            return self.getToken(BOCLParser.COLON, 0)
        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefExp" ):
                listener.enterDefExp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefExp" ):
                listener.exitDefExp(self)


    class FuncCallContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(BOCLParser.PrimaryExpressionContext,0)

        def functionCall(self):
            return self.getTypedRuleContext(BOCLParser.FunctionCallContext,0)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.DOT)
            else:
                return self.getToken(BOCLParser.DOT, i)
        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)
        def operator(self):
            return self.getTypedRuleContext(BOCLParser.OperatorContext,0)

        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFuncCall" ):
                listener.enterFuncCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFuncCall" ):
                listener.exitFuncCall(self)


    class UNIONContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def UNION(self):
            return self.getToken(BOCLParser.UNION, 0)
        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)

        def RPAREN(self):
            return self.getToken(BOCLParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUNION" ):
                listener.enterUNION(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUNION" ):
                listener.exitUNION(self)


    class PREPENDContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a BOCLParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Arrow(self):
            return self.getToken(BOCLParser.Arrow, 0)
        def PREPEND(self):
            return self.getToken(BOCLParser.PREPEND, 0)
        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.LPAREN)
            else:
                return self.getToken(BOCLParser.LPAREN, i)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.ExpressionContext,i)

        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)
        def SingleQuote(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.SingleQuote)
            else:
                return self.getToken(BOCLParser.SingleQuote, i)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.COMMA)
            else:
                return self.getToken(BOCLParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPREPEND" ):
                listener.enterPREPEND(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPREPEND" ):
                listener.exitPREPEND(self)



    def expression(self):

        localctx = BOCLParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_expression)
        self._la = 0 # Token type
        try:
            self.state = 1000
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,187,self._ctx)
            if la_ == 1:
                localctx = BOCLParser.BinaryContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 269
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==40 or _la==41:
                    self.state = 268
                    _la = self._input.LA(1)
                    if not(_la==40 or _la==41):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 271
                self.binaryExpression()
                self.state = 273
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
                if la_ == 1:
                    self.state = 272
                    self.expression()


                pass

            elif la_ == 2:
                localctx = BOCLParser.UnaryContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 275
                self.unaryExpression()
                self.state = 277
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
                if la_ == 1:
                    self.state = 276
                    self.expression()


                pass

            elif la_ == 3:
                localctx = BOCLParser.IfExpContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 279
                self.match(BOCLParser.IF)
                self.state = 280
                self.expression()
                pass

            elif la_ == 4:
                localctx = BOCLParser.ThenExpContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 281
                self.match(BOCLParser.THEN)
                self.state = 282
                self.expression()
                pass

            elif la_ == 5:
                localctx = BOCLParser.ElseExpContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 283
                self.match(BOCLParser.ELSE)
                self.state = 284
                self.expression()
                pass

            elif la_ == 6:
                localctx = BOCLParser.EndIfExpContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 285
                self.match(BOCLParser.ENDIF)
                self.state = 287
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
                if la_ == 1:
                    self.state = 286
                    self.expression()


                pass

            elif la_ == 7:
                localctx = BOCLParser.OCLISTYPEOFContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 289
                self.primaryExpression()
                self.state = 294
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,44,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 290
                        self.match(BOCLParser.DOT)
                        self.state = 291
                        self.match(BOCLParser.ID) 
                    self.state = 296
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,44,self._ctx)

                self.state = 297
                self.match(BOCLParser.DOT)
                self.state = 298
                self.match(BOCLParser.OCLISTYPEOF)
                self.state = 299
                self.match(BOCLParser.LPAREN)
                self.state = 300
                self.type_()
                self.state = 301
                self.match(BOCLParser.RPAREN)
                self.state = 303
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
                if la_ == 1:
                    self.state = 302
                    self.expression()


                pass

            elif la_ == 8:
                localctx = BOCLParser.OCLASTYPEContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 305
                self.primaryExpression()
                self.state = 310
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,46,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 306
                        self.match(BOCLParser.DOT)
                        self.state = 307
                        self.match(BOCLParser.ID) 
                    self.state = 312
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,46,self._ctx)

                self.state = 313
                self.match(BOCLParser.DOT)
                self.state = 314
                self.match(BOCLParser.OCLASTYPE)
                self.state = 315
                self.match(BOCLParser.LPAREN)
                self.state = 316
                self.type_()
                self.state = 317
                self.match(BOCLParser.RPAREN)
                self.state = 319
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
                if la_ == 1:
                    self.state = 318
                    self.expression()


                pass

            elif la_ == 9:
                localctx = BOCLParser.OCLISKINDOFContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 321
                self.primaryExpression()
                self.state = 326
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,48,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 322
                        self.match(BOCLParser.DOT)
                        self.state = 323
                        self.match(BOCLParser.ID) 
                    self.state = 328
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,48,self._ctx)

                self.state = 329
                self.match(BOCLParser.DOT)
                self.state = 330
                self.match(BOCLParser.OCLISKINDOF)
                self.state = 331
                self.match(BOCLParser.LPAREN)
                self.state = 332
                self.type_()
                self.state = 333
                self.match(BOCLParser.RPAREN)
                self.state = 335
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
                if la_ == 1:
                    self.state = 334
                    self.expression()


                pass

            elif la_ == 10:
                localctx = BOCLParser.ISEMPTYContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 338
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==10 or _la==22 or ((((_la - 78)) & ~0x3f) == 0 and ((1 << (_la - 78)) & 481) != 0):
                    self.state = 337
                    self.primaryExpression()


                self.state = 344
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 340
                    self.match(BOCLParser.DOT)
                    self.state = 341
                    self.match(BOCLParser.ID)
                    self.state = 346
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 347
                self.match(BOCLParser.Arrow)
                self.state = 348
                self.match(BOCLParser.ISEMPTY)
                self.state = 349
                self.match(BOCLParser.LPAREN)
                self.state = 350
                self.match(BOCLParser.RPAREN)
                self.state = 352
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,52,self._ctx)
                if la_ == 1:
                    self.state = 351
                    self.expression()


                self.state = 357
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,53,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 354
                        self.match(BOCLParser.RPAREN) 
                    self.state = 359
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,53,self._ctx)

                pass

            elif la_ == 11:
                localctx = BOCLParser.SUMContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 361
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==10 or _la==22 or ((((_la - 78)) & ~0x3f) == 0 and ((1 << (_la - 78)) & 481) != 0):
                    self.state = 360
                    self.primaryExpression()


                self.state = 367
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 363
                    self.match(BOCLParser.DOT)
                    self.state = 364
                    self.match(BOCLParser.ID)
                    self.state = 369
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 370
                self.match(BOCLParser.Arrow)
                self.state = 371
                self.match(BOCLParser.SUM)
                self.state = 372
                self.match(BOCLParser.LPAREN)
                self.state = 373
                self.match(BOCLParser.RPAREN)
                self.state = 375
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
                if la_ == 1:
                    self.state = 374
                    self.binaryFunctionCall()


                self.state = 378
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
                if la_ == 1:
                    self.state = 377
                    self.expression()


                self.state = 383
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,58,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 380
                        self.match(BOCLParser.RPAREN) 
                    self.state = 385
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,58,self._ctx)

                pass

            elif la_ == 12:
                localctx = BOCLParser.SIZEContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 387
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==10 or _la==22 or ((((_la - 78)) & ~0x3f) == 0 and ((1 << (_la - 78)) & 481) != 0):
                    self.state = 386
                    self.primaryExpression()


                self.state = 393
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 389
                    self.match(BOCLParser.DOT)
                    self.state = 390
                    self.match(BOCLParser.ID)
                    self.state = 395
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 396
                self.match(BOCLParser.Arrow)
                self.state = 397
                self.match(BOCLParser.SIZE)
                self.state = 398
                self.match(BOCLParser.LPAREN)
                self.state = 399
                self.match(BOCLParser.RPAREN)
                self.state = 401
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,61,self._ctx)
                if la_ == 1:
                    self.state = 400
                    self.binaryFunctionCall()


                self.state = 404
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
                if la_ == 1:
                    self.state = 403
                    self.expression()


                self.state = 409
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,63,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 406
                        self.match(BOCLParser.RPAREN) 
                    self.state = 411
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,63,self._ctx)

                pass

            elif la_ == 13:
                localctx = BOCLParser.INCLUDESContext(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 413
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==81:
                    self.state = 412
                    self.match(BOCLParser.Arrow)


                self.state = 415
                self.match(BOCLParser.INCLUDES)
                self.state = 416
                self.match(BOCLParser.LPAREN)
                self.state = 417
                self.expression()
                self.state = 418
                self.match(BOCLParser.RPAREN)
                self.state = 420
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,65,self._ctx)
                if la_ == 1:
                    self.state = 419
                    self.expression()


                self.state = 425
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,66,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 422
                        self.match(BOCLParser.RPAREN) 
                    self.state = 427
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,66,self._ctx)

                pass

            elif la_ == 14:
                localctx = BOCLParser.EXCLUDESContext(self, localctx)
                self.enterOuterAlt(localctx, 14)
                self.state = 429
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==81:
                    self.state = 428
                    self.match(BOCLParser.Arrow)


                self.state = 431
                self.match(BOCLParser.EXCLUDES)
                self.state = 432
                self.match(BOCLParser.LPAREN)
                self.state = 433
                self.expression()
                self.state = 434
                self.match(BOCLParser.RPAREN)
                self.state = 436
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
                if la_ == 1:
                    self.state = 435
                    self.expression()


                self.state = 441
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,69,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 438
                        self.match(BOCLParser.RPAREN) 
                    self.state = 443
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,69,self._ctx)

                pass

            elif la_ == 15:
                localctx = BOCLParser.SEQUENCEContext(self, localctx)
                self.enterOuterAlt(localctx, 15)
                self.state = 445
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==81:
                    self.state = 444
                    self.match(BOCLParser.Arrow)


                self.state = 450
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==22:
                    self.state = 447
                    self.match(BOCLParser.LPAREN)
                    self.state = 452
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 453
                self.match(BOCLParser.SEQUENCE)
                self.state = 457
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==24:
                    self.state = 454
                    self.match(BOCLParser.LBRACE)
                    self.state = 459
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 463
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,73,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 460
                        self.match(BOCLParser.LPAREN) 
                    self.state = 465
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,73,self._ctx)

                self.state = 478
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,77,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 467
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
                        if la_ == 1:
                            self.state = 466
                            self.match(BOCLParser.SingleQuote)


                        self.state = 469
                        self.expression()
                        self.state = 471
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
                        if la_ == 1:
                            self.state = 470
                            self.match(BOCLParser.SingleQuote)


                        self.state = 474
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
                        if la_ == 1:
                            self.state = 473
                            self.match(BOCLParser.COMMA)

                 
                    self.state = 480
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,77,self._ctx)

                self.state = 484
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,78,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 481
                        self.match(BOCLParser.RBRACE) 
                    self.state = 486
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,78,self._ctx)

                self.state = 490
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,79,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 487
                        self.match(BOCLParser.RPAREN) 
                    self.state = 492
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,79,self._ctx)

                self.state = 494
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,80,self._ctx)
                if la_ == 1:
                    self.state = 493
                    self.expression()


                pass

            elif la_ == 16:
                localctx = BOCLParser.SUBSEQUENCEContext(self, localctx)
                self.enterOuterAlt(localctx, 16)
                self.state = 497
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==81:
                    self.state = 496
                    self.match(BOCLParser.Arrow)


                self.state = 502
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==22:
                    self.state = 499
                    self.match(BOCLParser.LPAREN)
                    self.state = 504
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 505
                self.match(BOCLParser.SUBSEQUENCE)
                self.state = 509
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==24:
                    self.state = 506
                    self.match(BOCLParser.LBRACE)
                    self.state = 511
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 515
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,84,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 512
                        self.match(BOCLParser.LPAREN) 
                    self.state = 517
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,84,self._ctx)

                self.state = 530
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,88,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 519
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,85,self._ctx)
                        if la_ == 1:
                            self.state = 518
                            self.match(BOCLParser.SingleQuote)


                        self.state = 521
                        self.expression()
                        self.state = 523
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,86,self._ctx)
                        if la_ == 1:
                            self.state = 522
                            self.match(BOCLParser.SingleQuote)


                        self.state = 526
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,87,self._ctx)
                        if la_ == 1:
                            self.state = 525
                            self.match(BOCLParser.COMMA)

                 
                    self.state = 532
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,88,self._ctx)

                self.state = 536
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,89,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 533
                        self.match(BOCLParser.RPAREN) 
                    self.state = 538
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,89,self._ctx)

                self.state = 542
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,90,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 539
                        self.match(BOCLParser.RBRACE) 
                    self.state = 544
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,90,self._ctx)

                self.state = 546
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
                if la_ == 1:
                    self.state = 545
                    self.expression()


                pass

            elif la_ == 17:
                localctx = BOCLParser.ALLINSTANCESContext(self, localctx)
                self.enterOuterAlt(localctx, 17)
                self.state = 549
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==81:
                    self.state = 548
                    self.match(BOCLParser.Arrow)


                self.state = 551
                self.match(BOCLParser.ALLINSTANCES)
                self.state = 553 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 552
                        self.match(BOCLParser.LPAREN)

                    else:
                        raise NoViableAltException(self)
                    self.state = 555 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,93,self._ctx)

                self.state = 558
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 5187865230800387074) != 0) or ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 2068495) != 0):
                    self.state = 557
                    self.expression()


                self.state = 561 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 560
                        self.match(BOCLParser.RPAREN)

                    else:
                        raise NoViableAltException(self)
                    self.state = 563 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,95,self._ctx)

                self.state = 566
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,96,self._ctx)
                if la_ == 1:
                    self.state = 565
                    self.expression()


                pass

            elif la_ == 18:
                localctx = BOCLParser.ORDEREDSETContext(self, localctx)
                self.enterOuterAlt(localctx, 18)
                self.state = 569
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==81:
                    self.state = 568
                    self.match(BOCLParser.Arrow)


                self.state = 574
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==22:
                    self.state = 571
                    self.match(BOCLParser.LPAREN)
                    self.state = 576
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 577
                self.match(BOCLParser.ORDEREDSET)
                self.state = 578
                self.match(BOCLParser.LBRACE)
                self.state = 591
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & 5187865230800387074) != 0) or ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 2068495) != 0):
                    self.state = 580
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
                    if la_ == 1:
                        self.state = 579
                        self.match(BOCLParser.SingleQuote)


                    self.state = 582
                    self.expression()
                    self.state = 584
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
                    if la_ == 1:
                        self.state = 583
                        self.match(BOCLParser.SingleQuote)


                    self.state = 587
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==28:
                        self.state = 586
                        self.match(BOCLParser.COMMA)


                    self.state = 593
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 594
                self.match(BOCLParser.RBRACE)
                self.state = 598
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,103,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 595
                        self.match(BOCLParser.RPAREN) 
                    self.state = 600
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,103,self._ctx)

                self.state = 602
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
                if la_ == 1:
                    self.state = 601
                    self.expression()


                pass

            elif la_ == 19:
                localctx = BOCLParser.SUBORDEREDSETContext(self, localctx)
                self.enterOuterAlt(localctx, 19)
                self.state = 605
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==81:
                    self.state = 604
                    self.match(BOCLParser.Arrow)


                self.state = 610
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==22:
                    self.state = 607
                    self.match(BOCLParser.LPAREN)
                    self.state = 612
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 613
                self.match(BOCLParser.SUBORDEREDSET)
                self.state = 617
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==24:
                    self.state = 614
                    self.match(BOCLParser.LBRACE)
                    self.state = 619
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 623
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,108,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 620
                        self.match(BOCLParser.LPAREN) 
                    self.state = 625
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,108,self._ctx)

                self.state = 638
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,112,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 627
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,109,self._ctx)
                        if la_ == 1:
                            self.state = 626
                            self.match(BOCLParser.SingleQuote)


                        self.state = 629
                        self.expression()
                        self.state = 631
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,110,self._ctx)
                        if la_ == 1:
                            self.state = 630
                            self.match(BOCLParser.SingleQuote)


                        self.state = 634
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==28:
                            self.state = 633
                            self.match(BOCLParser.COMMA)

                 
                    self.state = 640
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,112,self._ctx)

                self.state = 644
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==25:
                    self.state = 641
                    self.match(BOCLParser.RBRACE)
                    self.state = 646
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 650
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,114,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 647
                        self.match(BOCLParser.RPAREN) 
                    self.state = 652
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,114,self._ctx)

                self.state = 654
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 5187865230800387074) != 0) or ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 2068495) != 0):
                    self.state = 653
                    self.expression()


                self.state = 656
                self.match(BOCLParser.RPAREN)
                pass

            elif la_ == 20:
                localctx = BOCLParser.SETContext(self, localctx)
                self.enterOuterAlt(localctx, 20)
                self.state = 658
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==81:
                    self.state = 657
                    self.match(BOCLParser.Arrow)


                self.state = 663
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==22:
                    self.state = 660
                    self.match(BOCLParser.LPAREN)
                    self.state = 665
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 666
                self.match(BOCLParser.SET)
                self.state = 670
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,118,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 667
                        self.match(BOCLParser.LPAREN) 
                    self.state = 672
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,118,self._ctx)

                self.state = 676
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==24:
                    self.state = 673
                    self.match(BOCLParser.LBRACE)
                    self.state = 678
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 691
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,123,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 680
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,120,self._ctx)
                        if la_ == 1:
                            self.state = 679
                            self.match(BOCLParser.SingleQuote)


                        self.state = 682
                        self.expression()
                        self.state = 684
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
                        if la_ == 1:
                            self.state = 683
                            self.match(BOCLParser.SingleQuote)


                        self.state = 687
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,122,self._ctx)
                        if la_ == 1:
                            self.state = 686
                            self.match(BOCLParser.COMMA)

                 
                    self.state = 693
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,123,self._ctx)

                self.state = 697
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,124,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 694
                        self.match(BOCLParser.RBRACE) 
                    self.state = 699
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,124,self._ctx)

                self.state = 703
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,125,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 700
                        self.match(BOCLParser.RPAREN) 
                    self.state = 705
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,125,self._ctx)

                self.state = 707
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,126,self._ctx)
                if la_ == 1:
                    self.state = 706
                    self.expression()


                pass

            elif la_ == 21:
                localctx = BOCLParser.BAGContext(self, localctx)
                self.enterOuterAlt(localctx, 21)
                self.state = 710
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==81:
                    self.state = 709
                    self.match(BOCLParser.Arrow)


                self.state = 715
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==22:
                    self.state = 712
                    self.match(BOCLParser.LPAREN)
                    self.state = 717
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 718
                self.match(BOCLParser.BAG)
                self.state = 722
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,129,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 719
                        self.match(BOCLParser.LPAREN) 
                    self.state = 724
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,129,self._ctx)

                self.state = 728
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==24:
                    self.state = 725
                    self.match(BOCLParser.LBRACE)
                    self.state = 730
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 743
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,134,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 732
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,131,self._ctx)
                        if la_ == 1:
                            self.state = 731
                            self.match(BOCLParser.SingleQuote)


                        self.state = 734
                        self.expression()
                        self.state = 736
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,132,self._ctx)
                        if la_ == 1:
                            self.state = 735
                            self.match(BOCLParser.SingleQuote)


                        self.state = 739
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,133,self._ctx)
                        if la_ == 1:
                            self.state = 738
                            self.match(BOCLParser.COMMA)

                 
                    self.state = 745
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,134,self._ctx)

                self.state = 749
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,135,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 746
                        self.match(BOCLParser.RBRACE) 
                    self.state = 751
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,135,self._ctx)

                self.state = 755
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,136,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 752
                        self.match(BOCLParser.RPAREN) 
                    self.state = 757
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,136,self._ctx)

                self.state = 759
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,137,self._ctx)
                if la_ == 1:
                    self.state = 758
                    self.expression()


                pass

            elif la_ == 22:
                localctx = BOCLParser.PREPENDContext(self, localctx)
                self.enterOuterAlt(localctx, 22)
                self.state = 761
                self.match(BOCLParser.Arrow)
                self.state = 762
                self.match(BOCLParser.PREPEND)
                self.state = 764 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 763
                        self.match(BOCLParser.LPAREN)

                    else:
                        raise NoViableAltException(self)
                    self.state = 766 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,138,self._ctx)

                self.state = 780
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & 5187865230800387074) != 0) or ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 2068495) != 0):
                    self.state = 769
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,139,self._ctx)
                    if la_ == 1:
                        self.state = 768
                        self.match(BOCLParser.SingleQuote)


                    self.state = 771
                    self.expression()
                    self.state = 773
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,140,self._ctx)
                    if la_ == 1:
                        self.state = 772
                        self.match(BOCLParser.SingleQuote)


                    self.state = 776
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==28:
                        self.state = 775
                        self.match(BOCLParser.COMMA)


                    self.state = 782
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 784 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 783
                        self.match(BOCLParser.RPAREN)

                    else:
                        raise NoViableAltException(self)
                    self.state = 786 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,143,self._ctx)

                self.state = 789
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,144,self._ctx)
                if la_ == 1:
                    self.state = 788
                    self.expression()


                pass

            elif la_ == 23:
                localctx = BOCLParser.LASTContext(self, localctx)
                self.enterOuterAlt(localctx, 23)
                self.state = 791
                self.match(BOCLParser.Arrow)
                self.state = 792
                self.match(BOCLParser.LAST)
                self.state = 793
                self.match(BOCLParser.LPAREN)
                self.state = 795 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 794
                        self.match(BOCLParser.RPAREN)

                    else:
                        raise NoViableAltException(self)
                    self.state = 797 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,145,self._ctx)

                self.state = 800
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,146,self._ctx)
                if la_ == 1:
                    self.state = 799
                    self.expression()


                pass

            elif la_ == 24:
                localctx = BOCLParser.APPENDContext(self, localctx)
                self.enterOuterAlt(localctx, 24)
                self.state = 802
                self.match(BOCLParser.Arrow)
                self.state = 803
                self.match(BOCLParser.APPEND)
                self.state = 804
                self.match(BOCLParser.LPAREN)
                self.state = 817
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & 5187865230800387074) != 0) or ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 2068495) != 0):
                    self.state = 806
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,147,self._ctx)
                    if la_ == 1:
                        self.state = 805
                        self.match(BOCLParser.SingleQuote)


                    self.state = 808
                    self.expression()
                    self.state = 810
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,148,self._ctx)
                    if la_ == 1:
                        self.state = 809
                        self.match(BOCLParser.SingleQuote)


                    self.state = 813
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==28:
                        self.state = 812
                        self.match(BOCLParser.COMMA)


                    self.state = 819
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 821 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 820
                        self.match(BOCLParser.RPAREN)

                    else:
                        raise NoViableAltException(self)
                    self.state = 823 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,151,self._ctx)

                self.state = 826
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,152,self._ctx)
                if la_ == 1:
                    self.state = 825
                    self.expression()


                pass

            elif la_ == 25:
                localctx = BOCLParser.COLLECTIONContext(self, localctx)
                self.enterOuterAlt(localctx, 25)
                self.state = 829
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==81:
                    self.state = 828
                    self.match(BOCLParser.Arrow)


                self.state = 831
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 63488) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 832
                self.match(BOCLParser.LPAREN)
                self.state = 841 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 833
                    self.match(BOCLParser.ID)
                    self.state = 836
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==27:
                        self.state = 834
                        self.match(BOCLParser.COLON)
                        self.state = 835
                        self.match(BOCLParser.ID)


                    self.state = 839
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==28:
                        self.state = 838
                        self.match(BOCLParser.COMMA)


                    self.state = 843 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==83):
                        break

                self.state = 845
                self.match(BOCLParser.PIPE)
                self.state = 846
                self.expression()
                self.state = 847
                self.match(BOCLParser.RPAREN)
                self.state = 849
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,157,self._ctx)
                if la_ == 1:
                    self.state = 848
                    self.endExpression()


                pass

            elif la_ == 26:
                localctx = BOCLParser.CollectionExpressionVariableContext(self, localctx)
                self.enterOuterAlt(localctx, 26)
                self.state = 852
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==81:
                    self.state = 851
                    self.match(BOCLParser.Arrow)


                self.state = 854
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 63488) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 855
                self.match(BOCLParser.LPAREN)
                self.state = 856
                self.expression()
                self.state = 857
                self.match(BOCLParser.RPAREN)
                self.state = 859
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,159,self._ctx)
                if la_ == 1:
                    self.state = 858
                    self.endExpression()


                pass

            elif la_ == 27:
                localctx = BOCLParser.SYMMETRICDIFFERENCEContext(self, localctx)
                self.enterOuterAlt(localctx, 27)
                self.state = 861
                self.match(BOCLParser.Arrow)
                self.state = 862
                self.match(BOCLParser.SYMMETRICDIFFERENCE)
                self.state = 863
                self.match(BOCLParser.LPAREN)
                self.state = 864
                self.expression()
                self.state = 866 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 865
                        self.match(BOCLParser.RPAREN)

                    else:
                        raise NoViableAltException(self)
                    self.state = 868 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,160,self._ctx)

                self.state = 871
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,161,self._ctx)
                if la_ == 1:
                    self.state = 870
                    self.expression()


                pass

            elif la_ == 28:
                localctx = BOCLParser.FIRSTContext(self, localctx)
                self.enterOuterAlt(localctx, 28)
                self.state = 873
                self.match(BOCLParser.Arrow)
                self.state = 874
                self.match(BOCLParser.FIRST)
                self.state = 875
                self.match(BOCLParser.LPAREN)
                self.state = 876
                self.match(BOCLParser.RPAREN)
                self.state = 878
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,162,self._ctx)
                if la_ == 1:
                    self.state = 877
                    self.expression()


                pass

            elif la_ == 29:
                localctx = BOCLParser.DERIVEContext(self, localctx)
                self.enterOuterAlt(localctx, 29)
                self.state = 880
                self.match(BOCLParser.Arrow)
                self.state = 881
                self.match(BOCLParser.DERIVE)
                self.state = 882
                self.match(BOCLParser.LPAREN)
                self.state = 883
                self.match(BOCLParser.RPAREN)
                self.state = 885
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,163,self._ctx)
                if la_ == 1:
                    self.state = 884
                    self.expression()


                pass

            elif la_ == 30:
                localctx = BOCLParser.UNIONContext(self, localctx)
                self.enterOuterAlt(localctx, 30)
                self.state = 887
                self.match(BOCLParser.Arrow)
                self.state = 888
                self.match(BOCLParser.UNION)
                self.state = 889
                self.match(BOCLParser.LPAREN)
                self.state = 890
                self.expression()
                self.state = 891
                self.match(BOCLParser.RPAREN)
                self.state = 893
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,164,self._ctx)
                if la_ == 1:
                    self.state = 892
                    self.expression()


                pass

            elif la_ == 31:
                localctx = BOCLParser.DefExpContext(self, localctx)
                self.enterOuterAlt(localctx, 31)
                self.state = 895
                self.match(BOCLParser.Def)
                self.state = 896
                self.match(BOCLParser.COLON)
                self.state = 897
                self.expression()
                pass

            elif la_ == 32:
                localctx = BOCLParser.DefIDAssignmentexpressionContext(self, localctx)
                self.enterOuterAlt(localctx, 32)
                self.state = 898
                self.match(BOCLParser.ID)
                self.state = 899
                self.match(BOCLParser.COLON)
                self.state = 900
                self.match(BOCLParser.ID)
                self.state = 901
                self.match(BOCLParser.EQUAL)
                self.state = 902
                self.expression()
                pass

            elif la_ == 33:
                localctx = BOCLParser.PrimaryExpContext(self, localctx)
                self.enterOuterAlt(localctx, 33)
                self.state = 906
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,165,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 903
                        self.match(BOCLParser.LPAREN) 
                    self.state = 908
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,165,self._ctx)

                self.state = 910
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,166,self._ctx)
                if la_ == 1:
                    self.state = 909
                    self.primaryExpression()


                self.state = 916
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,167,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 912
                        self.match(BOCLParser.DOT)
                        self.state = 913
                        self.match(BOCLParser.ID) 
                    self.state = 918
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,167,self._ctx)

                self.state = 920
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 567729531540996098) != 0):
                    self.state = 919
                    self.operator()


                self.state = 923
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==10 or _la==22 or ((((_la - 78)) & ~0x3f) == 0 and ((1 << (_la - 78)) & 481) != 0):
                    self.state = 922
                    self.primaryExpression()


                self.state = 927 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 925
                        self.match(BOCLParser.DOT)
                        self.state = 926
                        self.match(BOCLParser.ID)

                    else:
                        raise NoViableAltException(self)
                    self.state = 929 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,170,self._ctx)

                self.state = 932
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,171,self._ctx)
                if la_ == 1:
                    self.state = 931
                    self.expression()


                pass

            elif la_ == 34:
                localctx = BOCLParser.FuncCallContext(self, localctx)
                self.enterOuterAlt(localctx, 34)
                self.state = 934
                self.primaryExpression()
                self.state = 938
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==29:
                    self.state = 935
                    self.match(BOCLParser.DOT)
                    self.state = 940
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 944
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,173,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 941
                        self.match(BOCLParser.ID) 
                    self.state = 946
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,173,self._ctx)

                self.state = 947
                self.functionCall()
                self.state = 949
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,174,self._ctx)
                if la_ == 1:
                    self.state = 948
                    self.operator()


                self.state = 952
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,175,self._ctx)
                if la_ == 1:
                    self.state = 951
                    self.expression()


                pass

            elif la_ == 35:
                localctx = BOCLParser.ArrowexpContext(self, localctx)
                self.enterOuterAlt(localctx, 35)
                self.state = 954
                self.match(BOCLParser.Arrow)
                self.state = 955
                self.expression()
                pass

            elif la_ == 36:
                localctx = BOCLParser.NumberContext(self, localctx)
                self.enterOuterAlt(localctx, 36)
                self.state = 956
                self.match(BOCLParser.NUMBER)
                self.state = 958
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,176,self._ctx)
                if la_ == 1:
                    self.state = 957
                    self.expression()


                pass

            elif la_ == 37:
                localctx = BOCLParser.PredefinedfunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 37)
                self.state = 961
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==81:
                    self.state = 960
                    self.match(BOCLParser.Arrow)


                self.state = 963
                self.functionCall()
                self.state = 965
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,178,self._ctx)
                if la_ == 1:
                    self.state = 964
                    self.expression()


                pass

            elif la_ == 38:
                localctx = BOCLParser.SingleQuoteExpContext(self, localctx)
                self.enterOuterAlt(localctx, 38)
                self.state = 967
                self.match(BOCLParser.SingleQuote)
                self.state = 968
                self.expression()
                self.state = 970
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29:
                    self.state = 969
                    self.match(BOCLParser.DOT)


                self.state = 972
                self.match(BOCLParser.SingleQuote)
                self.state = 974
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,180,self._ctx)
                if la_ == 1:
                    self.state = 973
                    self.match(BOCLParser.DOT)


                self.state = 977
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,181,self._ctx)
                if la_ == 1:
                    self.state = 976
                    self.expression()


                pass

            elif la_ == 39:
                localctx = BOCLParser.DoubleDotsContext(self, localctx)
                self.enterOuterAlt(localctx, 39)
                self.state = 979
                self.match(BOCLParser.DoubleDots)
                self.state = 980
                self.expression()
                pass

            elif la_ == 40:
                localctx = BOCLParser.DoubleCOLONsContext(self, localctx)
                self.enterOuterAlt(localctx, 40)
                self.state = 982
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==40:
                    self.state = 981
                    self.match(BOCLParser.AND)


                self.state = 985
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==41:
                    self.state = 984
                    self.match(BOCLParser.OR)


                self.state = 988
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==83:
                    self.state = 987
                    self.match(BOCLParser.ID)


                self.state = 990
                self.match(BOCLParser.DoubleCOLON)
                self.state = 991
                self.expression()
                pass

            elif la_ == 41:
                localctx = BOCLParser.OpContext(self, localctx)
                self.enterOuterAlt(localctx, 41)
                self.state = 992
                self.operator()
                self.state = 994
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,185,self._ctx)
                if la_ == 1:
                    self.state = 993
                    self.numberORUserDefined()


                pass

            elif la_ == 42:
                localctx = BOCLParser.IDContext(self, localctx)
                self.enterOuterAlt(localctx, 42)
                self.state = 996
                self.primaryExpression()
                self.state = 998
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,186,self._ctx)
                if la_ == 1:
                    self.state = 997
                    self.expression()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def AND(self):
            return self.getToken(BOCLParser.AND, 0)

        def OR(self):
            return self.getToken(BOCLParser.OR, 0)

        def getRuleIndex(self):
            return BOCLParser.RULE_endExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndExpression" ):
                listener.enterEndExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndExpression" ):
                listener.exitEndExpression(self)




    def endExpression(self):

        localctx = BOCLParser.EndExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_endExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1003
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,188,self._ctx)
            if la_ == 1:
                self.state = 1002
                _la = self._input.LA(1)
                if not(_la==40 or _la==41):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1005
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryFunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operator(self):
            return self.getTypedRuleContext(BOCLParser.OperatorContext,0)


        def NUMBER(self):
            return self.getToken(BOCLParser.NUMBER, 0)

        def primaryExpression(self):
            return self.getTypedRuleContext(BOCLParser.PrimaryExpressionContext,0)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.DOT)
            else:
                return self.getToken(BOCLParser.DOT, i)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)

        def getRuleIndex(self):
            return BOCLParser.RULE_binaryFunctionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryFunctionCall" ):
                listener.enterBinaryFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryFunctionCall" ):
                listener.exitBinaryFunctionCall(self)




    def binaryFunctionCall(self):

        localctx = BOCLParser.BinaryFunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_binaryFunctionCall)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1007
            self.operator()
            self.state = 1017
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,190,self._ctx)
            if la_ == 1:
                self.state = 1008
                self.primaryExpression()
                self.state = 1013
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,189,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1009
                        self.match(BOCLParser.DOT)
                        self.state = 1010
                        self.match(BOCLParser.ID) 
                    self.state = 1015
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,189,self._ctx)

                pass

            elif la_ == 2:
                self.state = 1016
                self.match(BOCLParser.NUMBER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BinaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operator(self):
            return self.getTypedRuleContext(BOCLParser.OperatorContext,0)


        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.NUMBER)
            else:
                return self.getToken(BOCLParser.NUMBER, i)

        def dateLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.DateLiteralContext)
            else:
                return self.getTypedRuleContext(BOCLParser.DateLiteralContext,i)


        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(BOCLParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(BOCLParser.PrimaryExpressionContext,i)


        def DoubleCOLON(self):
            return self.getToken(BOCLParser.DoubleCOLON, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.ID)
            else:
                return self.getToken(BOCLParser.ID, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.DOT)
            else:
                return self.getToken(BOCLParser.DOT, i)

        def getRuleIndex(self):
            return BOCLParser.RULE_binaryExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryExpression" ):
                listener.enterBinaryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryExpression" ):
                listener.exitBinaryExpression(self)




    def binaryExpression(self):

        localctx = BOCLParser.BinaryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_binaryExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1029
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,192,self._ctx)
            if la_ == 1:
                self.state = 1019
                self.primaryExpression()
                self.state = 1024
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,191,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1020
                        self.match(BOCLParser.DOT)
                        self.state = 1021
                        self.match(BOCLParser.ID) 
                    self.state = 1026
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,191,self._ctx)

                pass

            elif la_ == 2:
                self.state = 1027
                self.match(BOCLParser.NUMBER)
                pass

            elif la_ == 3:
                self.state = 1028
                self.dateLiteral()
                pass


            self.state = 1035
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==29:
                self.state = 1031
                self.match(BOCLParser.DOT)
                self.state = 1032
                self.match(BOCLParser.ID)
                self.state = 1037
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1038
            self.operator()
            self.state = 1053
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,195,self._ctx)
            if la_ == 1:
                self.state = 1039
                self.primaryExpression()
                self.state = 1040
                self.match(BOCLParser.DoubleCOLON)
                self.state = 1041
                self.match(BOCLParser.ID)
                pass

            elif la_ == 2:
                self.state = 1043
                self.primaryExpression()
                self.state = 1048
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,194,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1044
                        self.match(BOCLParser.DOT)
                        self.state = 1045
                        self.match(BOCLParser.ID) 
                    self.state = 1050
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,194,self._ctx)

                pass

            elif la_ == 3:
                self.state = 1051
                self.match(BOCLParser.NUMBER)
                pass

            elif la_ == 4:
                self.state = 1052
                self.dateLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def NOT(self):
            return self.getToken(BOCLParser.NOT, 0)

        def MINUS(self):
            return self.getToken(BOCLParser.MINUS, 0)

        def PLUS(self):
            return self.getToken(BOCLParser.PLUS, 0)

        def Divide(self):
            return self.getToken(BOCLParser.Divide, 0)

        def getRuleIndex(self):
            return BOCLParser.RULE_unaryExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryExpression" ):
                listener.enterUnaryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryExpression" ):
                listener.exitUnaryExpression(self)




    def unaryExpression(self):

        localctx = BOCLParser.UnaryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_unaryExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1055
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 63054792829698050) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1056
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(BOCLParser.EQUAL, 0)

        def NOTEQUAL(self):
            return self.getToken(BOCLParser.NOTEQUAL, 0)

        def LT(self):
            return self.getToken(BOCLParser.LT, 0)

        def LE(self):
            return self.getToken(BOCLParser.LE, 0)

        def GT(self):
            return self.getToken(BOCLParser.GT, 0)

        def GE(self):
            return self.getToken(BOCLParser.GE, 0)

        def PLUS(self):
            return self.getToken(BOCLParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(BOCLParser.MINUS, 0)

        def EMPTYSTRING(self):
            return self.getToken(BOCLParser.EMPTYSTRING, 0)

        def Divide(self):
            return self.getToken(BOCLParser.Divide, 0)

        def AND(self):
            return self.getToken(BOCLParser.AND, 0)

        def OR(self):
            return self.getToken(BOCLParser.OR, 0)

        def XOR(self):
            return self.getToken(BOCLParser.XOR, 0)

        def IMPLIES(self):
            return self.getToken(BOCLParser.IMPLIES, 0)

        def getRuleIndex(self):
            return BOCLParser.RULE_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator" ):
                listener.enterOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator" ):
                listener.exitOperator(self)




    def operator(self):

        localctx = BOCLParser.OperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1058
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 567729531540996098) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberORUserDefinedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(BOCLParser.NUMBER, 0)

        def ID(self):
            return self.getToken(BOCLParser.ID, 0)

        def SingleQuote(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.SingleQuote)
            else:
                return self.getToken(BOCLParser.SingleQuote, i)

        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(BOCLParser.RPAREN, 0)

        def getRuleIndex(self):
            return BOCLParser.RULE_numberORUserDefined

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberORUserDefined" ):
                listener.enterNumberORUserDefined(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberORUserDefined" ):
                listener.exitNumberORUserDefined(self)




    def numberORUserDefined(self):

        localctx = BOCLParser.NumberORUserDefinedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_numberORUserDefined)
        self._la = 0 # Token type
        try:
            self.state = 1074
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [84]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1060
                self.match(BOCLParser.NUMBER)
                pass
            elif token in [31, 83]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1062
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==31:
                    self.state = 1061
                    self.match(BOCLParser.SingleQuote)


                self.state = 1064
                self.match(BOCLParser.ID)
                self.state = 1066
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,197,self._ctx)
                if la_ == 1:
                    self.state = 1065
                    self.match(BOCLParser.LPAREN)


                self.state = 1069
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,198,self._ctx)
                if la_ == 1:
                    self.state = 1068
                    self.match(BOCLParser.RPAREN)


                self.state = 1072
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,199,self._ctx)
                if la_ == 1:
                    self.state = 1071
                    self.match(BOCLParser.SingleQuote)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrimaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(BOCLParser.LiteralContext,0)


        def SELF(self):
            return self.getToken(BOCLParser.SELF, 0)

        def functionCall(self):
            return self.getTypedRuleContext(BOCLParser.FunctionCallContext,0)


        def LPAREN(self):
            return self.getToken(BOCLParser.LPAREN, 0)

        def expression(self):
            return self.getTypedRuleContext(BOCLParser.ExpressionContext,0)


        def RPAREN(self):
            return self.getToken(BOCLParser.RPAREN, 0)

        def ID(self):
            return self.getToken(BOCLParser.ID, 0)

        def getRuleIndex(self):
            return BOCLParser.RULE_primaryExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimaryExpression" ):
                listener.enterPrimaryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimaryExpression" ):
                listener.exitPrimaryExpression(self)




    def primaryExpression(self):

        localctx = BOCLParser.PrimaryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_primaryExpression)
        try:
            self.state = 1084
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,201,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1076
                self.literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1077
                self.match(BOCLParser.SELF)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1078
                self.functionCall()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1079
                self.match(BOCLParser.LPAREN)
                self.state = 1080
                self.expression()
                self.state = 1081
                self.match(BOCLParser.RPAREN)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1083
                self.match(BOCLParser.ID)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(BOCLParser.NUMBER, 0)

        def STRING_LITERAL(self):
            return self.getToken(BOCLParser.STRING_LITERAL, 0)

        def BOOLEAN_LITERAL(self):
            return self.getToken(BOCLParser.BOOLEAN_LITERAL, 0)

        def NULL(self):
            return self.getToken(BOCLParser.NULL, 0)

        def getRuleIndex(self):
            return BOCLParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)




    def literal(self):

        localctx = BOCLParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1086
            _la = self._input.LA(1)
            if not(((((_la - 78)) & ~0x3f) == 0 and ((1 << (_la - 78)) & 449) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE(self):
            return self.getToken(BOCLParser.DATE, 0)

        def DoubleCOLON(self):
            return self.getToken(BOCLParser.DoubleCOLON, 0)

        def LPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.LPAREN)
            else:
                return self.getToken(BOCLParser.LPAREN, i)

        def RPAREN(self, i:int=None):
            if i is None:
                return self.getTokens(BOCLParser.RPAREN)
            else:
                return self.getToken(BOCLParser.RPAREN, i)

        def DOT(self):
            return self.getToken(BOCLParser.DOT, 0)

        def NUMBER(self):
            return self.getToken(BOCLParser.NUMBER, 0)

        def getRuleIndex(self):
            return BOCLParser.RULE_dateLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateLiteral" ):
                listener.enterDateLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateLiteral" ):
                listener.exitDateLiteral(self)




    def dateLiteral(self):

        localctx = BOCLParser.DateLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_dateLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1088
            self.match(BOCLParser.DATE)
            self.state = 1090
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,202,self._ctx)
            if la_ == 1:
                self.state = 1089
                self.match(BOCLParser.DoubleCOLON)


            self.state = 1093
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==2 or _la==3:
                self.state = 1092
                _la = self._input.LA(1)
                if not(_la==2 or _la==3):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1096
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,204,self._ctx)
            if la_ == 1:
                self.state = 1095
                self.match(BOCLParser.LPAREN)


            self.state = 1099
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,205,self._ctx)
            if la_ == 1:
                self.state = 1098
                self.match(BOCLParser.RPAREN)


            self.state = 1102
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,206,self._ctx)
            if la_ == 1:
                self.state = 1101
                self.match(BOCLParser.DOT)


            self.state = 1105
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 1104
                self.match(BOCLParser.T__3)


            self.state = 1108
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,208,self._ctx)
            if la_ == 1:
                self.state = 1107
                self.match(BOCLParser.LPAREN)


            self.state = 1111
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,209,self._ctx)
            if la_ == 1:
                self.state = 1110
                self.match(BOCLParser.NUMBER)


            self.state = 1114
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,210,self._ctx)
            if la_ == 1:
                self.state = 1113
                self.match(BOCLParser.RPAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





