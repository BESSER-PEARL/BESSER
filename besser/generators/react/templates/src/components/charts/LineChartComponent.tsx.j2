import React, { CSSProperties, useState, useCallback, useEffect } from "react";
import {
  CartesianGrid,
  Legend,
  Line,
  LineChart,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
} from "recharts";

interface SeriesConfig {
  name: string;
  label?: string;
  color?: string;
  'data-source'?: string;
  dataSource?: string;
  endpoint?: string;
  'label-field'?: string;
  labelField?: string;
  'data-field'?: string;
  dataField?: string;
  filter?: string;
  data?: Array<{ name: string; value: number }>;
  fetchedData?: any[];  // Pre-fetched data from Renderer
}

interface Props {
  id: string;
  title?: string;
  color?: string;
  data?: any[];
  series?: SeriesConfig[];
  labelField?: string;
  dataField?: string | string[];
  options?: Record<string, any>;
  styles?: CSSProperties;
}

const defaultColors = ["#4a90e2", "#10B981", "#F97316", "#F43F5E", "#8B5CF6", "#EC4899", "#06B6D4", "#84CC16"];

// API base URL - adjust based on your backend
const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';

// Helper to get nested value from object using dot notation (e.g., "measures.value")
// Handles arrays by getting first element's value
const getNestedValue = (obj: any, path: string): any => {
  if (!path || !obj) return undefined;
  // If no dot, just return direct property
  if (!path.includes('.')) return obj[path];
  // Navigate through nested properties
  const parts = path.split('.');
  let value = obj;
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    if (value == null) return undefined;
    
    // If current value is an array, get the first element and continue from there
    if (Array.isArray(value)) {
      if (value.length === 0) return undefined;
      // Get first element
      value = value[0];
    }
    
    value = value[part];
  }
  return value;
};

// Check if a field uses dot notation (related class attribute)
const isNestedField = (field: string): boolean => field?.includes('.') || false;

export const LineChartComponent: React.FC<Props> = ({
  id,
  title,
  color,
  data: propData,
  series: propSeries,
  labelField,
  dataField,
  options,
  styles,
}) => {
  // State for fetched data per series
  const [seriesData, setSeriesData] = useState<Map<string, any[]>>(new Map());
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Track visible series for clickable legend
  const [hiddenSeries, setHiddenSeries] = useState<Set<string>>(new Set());

  // Normalize series from props or create from single dataField
  const series: SeriesConfig[] = propSeries && propSeries.length > 0 
    ? propSeries 
    : (Array.isArray(dataField) 
        ? dataField.map((field, i) => ({ name: field, color: defaultColors[i % defaultColors.length], dataField: field }))
        : dataField 
          ? [{ name: dataField, color: color || defaultColors[0], dataField }]
          : []);

  // Fetch data from backend for each series that has a data-source
  useEffect(() => {
    const fetchSeriesData = async () => {
      const newSeriesData = new Map<string, any[]>();
      let hasDataSources = false;

      for (const s of series) {
        const labelFieldName = s['label-field'] || s.labelField || 'name';
        const dataFieldName = s['data-field'] || s.dataField || 'value';

        // Check for fetchedData first (pre-fetched by Renderer)
        if (s.fetchedData && s.fetchedData.length > 0) {
          // Transform fetchedData the same way we transform fetched data
          const chartData = Array.isArray(s.fetchedData) ? s.fetchedData.map((item: any) => {
            const label = getNestedValue(item, labelFieldName);
            const value = getNestedValue(item, dataFieldName);
            return {
              name: label,
              value: typeof value === 'number' ? value : parseFloat(value) || 0
            };
          }) : [];
          newSeriesData.set(s.name, chartData);
          hasDataSources = true;
          continue;
        }

        const endpoint = s.endpoint;
        const dataSourceId = s['data-source'] || s.dataSource;

        if (endpoint || dataSourceId) {
          hasDataSources = true;
          try {
            // Use endpoint if available, otherwise build from dataSource
            // Add ?detailed=true if using nested fields (e.g., measure.value)
            const needsDetailed = isNestedField(labelFieldName) || isNestedField(dataFieldName);
            const detailedParam = needsDetailed ? '?detailed=true' : '';
            const fetchUrl = endpoint 
              ? (endpoint.startsWith('/') ? `${API_BASE_URL}${endpoint}${detailedParam}` : endpoint + detailedParam)
              : `${API_BASE_URL}/${dataSourceId}/${detailedParam}`;
            
            const response = await fetch(fetchUrl);
            if (response.ok) {
              let rawData = await response.json();
              // Handle wrapped responses
              if (!Array.isArray(rawData) && typeof rawData === 'object') {
                const arrayKey = Object.keys(rawData).find(k => Array.isArray(rawData[k]));
                if (arrayKey) rawData = rawData[arrayKey];
              }
              // Transform data to chart format using field names (supports dot notation for nested values)
              const chartData = Array.isArray(rawData) ? rawData.map((item: any) => ({
                name: getNestedValue(item, labelFieldName) || item.name || '',
                value: parseFloat(getNestedValue(item, dataFieldName)) || item.value || 0,
              })) : [];
              newSeriesData.set(s.name, chartData);
            } else {
              // Use static data from series config as fallback
              newSeriesData.set(s.name, s.data || []);
            }
          } catch (err) {
            console.warn(`Failed to fetch data for series ${s.name}:`, err);
            // Use static data from series config as fallback
            newSeriesData.set(s.name, s.data || []);
          }
        } else {
          // No data source - use static data from series config
          newSeriesData.set(s.name, s.data || []);
        }
      }

      if (hasDataSources || series.length > 0) {
        setSeriesData(newSeriesData);
      }
    };

    if (series.length > 0) {
      setLoading(true);
      fetchSeriesData().finally(() => setLoading(false));
    }
  }, [series]);

  // Merge all series data into a single dataset for recharts
  const mergedData = React.useMemo(() => {
    if (propData && propData.length > 0) return propData;
    
    const dataMap = new Map<string, any>();
    
    series.forEach((s) => {
      const data = seriesData.get(s.name) || s.data || [];
      data.forEach((point: any) => {
        const key = point.name || point.label || '';
        if (!dataMap.has(key)) {
          dataMap.set(key, { name: key });
        }
        dataMap.get(key)[s.name] = point.value;
      });
    });
    
    return Array.from(dataMap.values());
  }, [propData, series, seriesData]);

  const containerStyle: CSSProperties = {
    width: "100%",
    height: "400px",
    marginBottom: "20px",
    ...styles,
  };

  const strokeWidth = options?.lineWidth ?? 2;
  const showGrid = options?.showGrid ?? true;
  const showLegend = options?.showLegend ?? true;
  const showTooltip = options?.showTooltip ?? true;
  const legendPosition = options?.legendPosition || "top";

  // Handle legend click to toggle series visibility
  const handleLegendClick = useCallback((dataKey: string) => {
    setHiddenSeries(prev => {
      const newSet = new Set(prev);
      if (newSet.has(dataKey)) {
        newSet.delete(dataKey);
      } else {
        newSet.add(dataKey);
      }
      return newSet;
    });
  }, []);

  // Custom legend with clickable items
  const renderLegend = (props: any) => {
    const { payload } = props;
    return (
      <div style={{ display: 'flex', justifyContent: 'center', gap: '20px', flexWrap: 'wrap', padding: '10px' }}>
        {payload.map((entry: any, index: number) => (
          <div
            key={`legend-${index}`}
            onClick={() => handleLegendClick(entry.dataKey)}
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: '6px',
              cursor: 'pointer',
              opacity: hiddenSeries.has(entry.dataKey) ? 0.4 : 1,
              textDecoration: hiddenSeries.has(entry.dataKey) ? 'line-through' : 'none',
              transition: 'opacity 0.2s',
            }}
          >
            <span style={{
              width: '14px',
              height: '14px',
              backgroundColor: entry.color,
              borderRadius: '2px',
            }} />
            <span style={{ fontSize: '14px', color: '#374151' }}>{entry.value}</span>
          </div>
        ))}
      </div>
    );
  };

  if (loading) {
    return (
      <div id={id} style={containerStyle}>
        {title && <h3 style={{ textAlign: "center", marginBottom: "10px" }}>{title}</h3>}
        <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '360px' }}>
          Loading...
        </div>
      </div>
    );
  }

  return (
    <div id={id} style={containerStyle}>
      {title && <h3 style={{ textAlign: "center", marginBottom: "10px" }}>{title}</h3>}
      <ResponsiveContainer width="100%" height={360}>
        <LineChart data={mergedData} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
          {showGrid && <CartesianGrid strokeDasharray="3 3" stroke={options?.gridColor} />}
          <XAxis dataKey="name" />
          <YAxis />
          {showTooltip && <Tooltip />}
          {showLegend && <Legend verticalAlign={legendPosition} content={renderLegend} />}
          {series.map((s, index) => (
            <Line
              key={s.name}
              type={options?.curveType || "monotone"}
              dataKey={s.name}
              name={s.name}
              stroke={s.color || defaultColors[index % defaultColors.length]}
              strokeWidth={strokeWidth}
              dot={options?.dotSize ? { r: options.dotSize } : true}
              isAnimationActive={options?.animate ?? true}
              hide={hiddenSeries.has(s.name)}
            />
          ))}
        </LineChart>
      </ResponsiveContainer>
    </div>
  );
};
