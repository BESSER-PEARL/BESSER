grammar OCLs;

//oclFile: contextDeclaration;

//contextDeclaration: CONTEXT ID;



// Top-level constructs
oclFile: (contextDeclaration | expression)* ;

// Context Declarations
contextDeclaration: CONTEXT ID (COLON type)? LBRACE? constraint* RBRACE? ;
constraint: (INV | PRE | POST) ID? COLON expression SEMI ;

type: BOOLEAN_TYPE | INTEGER_TYPE | REAL_TYPE | STRING_TYPE | OCLANY | OCLVOID | collectionType | userDefinedType ;
collectionType: SET LT type GT | BAG LT type  GT| SEQUENCE LT type GT | ORDEREDSET LT type GT;
userDefinedType: ID ;

expression:
           binaryExpression #binary
          | unaryExpression #unary
          | IF expression THEN expression ELSE expression ENDIF  #if
          | primaryExpression  (DOT ID)* DOT OCLISTYPEOF LPAREN type RPAREN #OCLISTYPEOF
          | primaryExpression  (DOT ID)* DOT OCLASTYPE LPAREN type RPAREN #OCLASTYPE
          | primaryExpression  (DOT ID)* DOT OCLISKINDOF LPAREN type RPAREN #OCLISKINDOF

          | primaryExpression  (DOT ID)* Arrow ISEMPTY LPAREN RPAREN expression? #ISEMPTY
          | primaryExpression  (DOT ID)* Arrow SUM LPAREN RPAREN expression?  #SUM
          | primaryExpression  (DOT ID)* Arrow SIZE LPAREN RPAREN expression? #SIZE

          | primaryExpression  (DOT ID)* Arrow INCLUDES LPAREN expression RPAREN expression? #INCLUDES
          | primaryExpression  (DOT ID)* Arrow EXCLUDES LPAREN expression RPAREN  expression? #EXCLUDES

          | LPAREN? SEQUENCE LBRACE (SingleQuote? ID SingleQuote? COMMA?)* RBRACE RPAREN? expression? #SEQUENCE
          | expression Arrow SUBORDEREDSET LPAREN expression COMMA expression RPAREN  #SUBORDEREDSET
          | Arrow PREPEND LPAREN (SingleQuote? ID SingleQuote? COMMA?)* RPAREN expression? #PREPEND
          | Arrow LAST LPAREN RPAREN  #LAST
          | Arrow APPEND LPAREN (SingleQuote? ID SingleQuote? COMMA?)*  RPAREN expression   #APPEND
          | Arrow SYMMETRICDIFFERENCE LPAREN expression RPAREN expression #SYMMETRICDIFFERENCE
          | Arrow FIRST LPAREN RPAREN expression  #FIRST
          | Arrow DERIVE LPAREN RPAREN expression  #DERIVE
          | Arrow UNION LPAREN expression RPAREN  expression#UNION
          | primaryExpression  (DOT ID)* #PrimaryExp
          | operator  numberORUserDefined #op
          | Arrow expression #arrowexp


          //  | primaryExpression  (DOT ID)* DOT ALLINSTANCES LPAREN RPAREN expression  #ALLINSTANCES Not working, check why


  ;



binaryExpression: primaryExpression  (DOT ID)* operator primaryExpression (DOT ID)* ;
unaryExpression: (NOT | MINUS) primaryExpression ;

operator: EQUAL | NOTEQUAL| LT | LE | GT | GE | PLUS | MINUS | EMPTYSTRING | Divide | AND | OR | XOR | IMPLIES ; // Added 'xor' and 'implies'

numberORUserDefined: NUMBER |primaryExpression (DOT primaryExpression)* | expression;

primaryExpression: literal | SELF | functionCall | LPAREN expression RPAREN | ID  ;

literal: NUMBER | STRING_LITERAL | BOOLEAN_LITERAL | NULL ;
// Function and Property Calls

functionCall: ID LPAREN (expression (COMMA expression)*)? RPAREN ;

CONTEXT: 'context';
// Keywords
INV: 'inv' ;
PRE: 'pre' ;
POST: 'post' ;
SELF: 'self' ;
FORALL: 'forAll' ;
EXISTS: 'exists' ;
SELECT: 'select' ;
COLLECT: 'collect' ;
OCLANY: 'OclAny' ;
OCLVOID: 'OclVoid' ;
WS: [ \t\r\n]+ -> skip ;


// Symbols
LPAREN: '(' ;
RPAREN: ')' ;
LBRACE: '{' ;
RBRACE: '}' ;
SEMI: ';' ;
COLON: ':' ;
COMMA: ',' ;
DOT: '.' ;
EQUAL: '=' ;
SingleQuote: '\'';
BOOLEAN_TYPE: 'Boolean' ;
INTEGER_TYPE: 'Integer' ;
REAL_TYPE: 'Real' ;
STRING_TYPE: 'String' ;
IF: 'if' ;
THEN: 'then' ;
ELSE: 'else' ;
ENDIF: 'endif' ;
AND: 'and' ;
OR: 'or' ;
NOT: 'not' ;
NOTEQUAL: '<>' ;
LT: '<' ;
LE: '<=' ;
GT: '>' ;
GE: '>=' ;
PIPE: '|' ;
SET: 'set';
BAG: 'Bag';
SEQUENCE: 'Sequence';
ORDEREDSET: 'OrderedSet';
MINUS: '-';
PLUS: '+';
Divide: '/';
EMPTYSTRING: ' ';
XOR: 'xor';
IMPLIES: 'implies';
OCLASTYPE: 'oclAsType';
OCLISTYPEOF: 'oclIsTypeOf';
OCLISKINDOF: 'oclIsKindOf';
ALLINSTANCES: 'allInstances';
ISEMPTY: 'isEmpty';
SUM: 'sum';
SIZE: 'size';
INCLUDES: 'includes';
EXCLUDES: 'excludes';
SUBSEQUENCE: 'subSequence';
SUBORDEREDSET: 'subOrderedSet';
PREPEND: 'prepend';
LAST: 'last';
APPEND: 'append';
SYMMETRICDIFFERENCE: 'symmetricDifference';
FIRST: 'first';
DERIVE: 'derive';
UNION: 'union';
NULL: 'null';
LET: 'let';
IN: 'in';
Arrow: '->' | 'â†’';


// Basic tokens
ID: [a-zA-Z_] [a-zA-Z_0-9]* ;
NUMBER: [0-9]+ ('.' [0-9]+)? ;
STRING_LITERAL: '"' ( ~["\\] | '\\' . )* '"' ;
BOOLEAN_LITERAL: 'true' | 'false';
COMMENT: '/*' .*? '*/' -> skip ;
LINE_COMMENT: '//' ~[\r\n]* -> skip ;