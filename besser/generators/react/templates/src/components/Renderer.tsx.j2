import React, { CSSProperties, useEffect, useState } from "react";
import axios from "axios";
import { useNavigate } from "react-router-dom";
import { applyStyle, StyleData } from "../utils/applyStyle";
{% if 'BarChart' in used_components %}import { BarChartComponent } from "./charts/BarChartComponent";
{% endif %}{% if 'LineChart' in used_components %}import { LineChartComponent } from "./charts/LineChartComponent";
{% endif %}{% if 'PieChart' in used_components %}import { PieChartComponent } from "./charts/PieChartComponent";
{% endif %}{% if 'RadialBarChart' in used_components %}import { RadialBarChartComponent } from "./charts/RadialBarChartComponent";
{% endif %}{% if 'RadarChart' in used_components %}import { RadarChartComponent } from "./charts/RadarChartComponent";
{% endif %}{% if 'MetricCard' in used_components %}import { MetricCardComponent } from "./charts/MetricCardComponent";
{% endif %}{% if 'Table' in used_components %}import { TableComponent } from "./table/TableComponent";
{% endif %}import { AgentComponent } from "./AgentComponent";
import { MethodButton } from "./MethodButton";
{% if 'Table' in used_components %}import "./table/TableComponent.css";
{% endif %}

export interface RendererProps {
  component: any;
  styles: StyleData[];
}

export const Renderer: React.FC<RendererProps> = ({ component, styles }) => {
  // BrowserRouter should be set up in index.tsx - hooks must be called unconditionally
  const navigate = useNavigate();
  
  // All hooks must be at the top level - declare all states here
  const [chartData, setChartData] = useState<any[]>(component.data ?? []);
  const [seriesData, setSeriesData] = useState<{[key: string]: any[]}>({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [listData, setListData] = useState<any[]>([]);
  
  let style = applyStyle(`#${component.id}`, styles) as CSSProperties;
  if (component.class_list && Array.isArray(component.class_list)) {
    component.class_list.forEach((cls: string) => {
      // Ensure class selectors have the . prefix for proper CSS matching
      const classSelector = cls.startsWith('.') ? cls : `.${cls}`;
      style = { ...style, ...applyStyle(classSelector, styles) };
    });
  }

  // Helper to check if a field uses dot notation (nested field like measures.value)
  const isNestedField = (field: string | undefined) => field?.includes('.') || false;

  // Helper to get nested value from object using dot notation (e.g., "measures.value")
  const getNestedValue = (obj: any, path: string): any => {
    if (!path || !obj) return undefined;
    if (!path.includes('.')) return obj[path];
    const parts = path.split('.');
    let value = obj;
    for (const part of parts) {
      if (value == null) return undefined;
      if (Array.isArray(value)) value = value[0];
      if (value == null) return undefined;
      value = value[part];
    }
    return value;
  };

  // Helper to parse series definitions that may come as strings from the designer
  const parseSeries = (rawSeries: any): any[] => {
    if (!rawSeries) return [];
    if (Array.isArray(rawSeries)) return rawSeries;
    if (typeof rawSeries === "string") {
      try {
        const parsed = JSON.parse(rawSeries);
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }
    return [];
  };

  const resolveSeriesName = (s: any, index: number) => s?.name || s?.label || `Series ${index + 1}`;
  const resolveSeriesLabelField = (s: any) =>
    s?.labelField || s?.["label-field"] || component.data_binding?.label_field || "name";
  const resolveSeriesDataField = (s: any) =>
    s?.dataField || s?.["data-field"] || component.data_binding?.data_field || "value";
  const toNumeric = (value: any) => {
    if (value === null || value === undefined) return 0;
    const num = typeof value === "number" ? value : parseFloat(value);
    return Number.isFinite(num) ? num : 0;
  };

  // Normalize series with resolved names/fields and attach pre-fetched data if present
  const normalizedSeries = parseSeries(component.series).map((s: any, index: number) => ({
    ...s,
    name: resolveSeriesName(s, index),
    labelField: resolveSeriesLabelField(s),
    dataField: resolveSeriesDataField(s),
    fetchedData: s.fetchedData,
  }));

  // Helper to prepare chart data from series - merges fetched series data into chart-ready format
  const prepareChartDataFromSeries = (
    series: any[],
    seriesDataMap: { [key: string]: any[] }
  ): any[] => {
    if (!series || series.length === 0) return [];

    const combined: Record<string, any> = {};
    series.forEach((s) => {
      const sourceData = seriesDataMap[s.name] ?? s.fetchedData ?? s.data ?? [];
      if (!Array.isArray(sourceData)) return;

      sourceData.forEach((item: any) => {
        const label = getNestedValue(item, s.labelField) ?? item?.[s.labelField] ?? item?.name ?? item?.label ?? "";
        const value = toNumeric(getNestedValue(item, s.dataField) ?? item?.[s.dataField] ?? item?.value);
        const key = String(label ?? "");

        if (!combined[key]) {
          combined[key] = { name: key };
        }
        combined[key][s.name] = value;
      });
    });

    return Object.values(combined);
  };

  // Helper to prepare series with fetched data for multi-series charts (like LineChart)
  const prepareSeries = (series: any[], seriesDataMap: { [key: string]: any[] }): any[] => {
    if (!series || series.length === 0) return [];
    return series.map((s: any, index: number) => ({
      ...s,
      name: resolveSeriesName(s, index),
      labelField: resolveSeriesLabelField(s),
      dataField: resolveSeriesDataField(s),
      fetchedData: seriesDataMap[resolveSeriesName(s, index)] ?? s.fetchedData,
    }));
  };

  // Chart series data fetching effect - fetches data for each series with an endpoint
  useEffect(() => {
    const series = normalizedSeries;
    if (["bar-chart", "line-chart", "pie-chart", "radial-bar-chart", "radar-chart"].includes(component.type)) {
      if (series && Array.isArray(series) && series.length > 0) {
        // Check if any series has an endpoint to fetch
        const seriesWithEndpoints = series.filter((s: any) => s.endpoint || s.dataSource || s["data-source"]);
        if (seriesWithEndpoints.length > 0) {
          setLoading(true);
          setError(null);
          const backendBase = process.env.REACT_APP_API_URL || "http://localhost:8000";
          
          const fetchPromises = seriesWithEndpoints.map((s: any) => {
            const seriesName = s.name || s.label || "Series";
            const endpoint = s.endpoint || `/${s.dataSource || s["data-source"]}/`;
            // Check if this series uses nested fields (e.g., measures.value) - need detailed=true
            const labelField = s.labelField || s["label-field"];
            const dataField = s.dataField || s["data-field"];
            const needsDetailed = isNestedField(labelField) || isNestedField(dataField);
            const detailedParam = needsDetailed ? '?detailed=true' : '';
            const url = endpoint.startsWith("/") ? backendBase + endpoint + detailedParam : endpoint + detailedParam;
            return axios.get(url)
              .then((res) => {
                let data: any[] = [];
                if (Array.isArray(res.data)) {
                  data = res.data;
                } else if (res.data && typeof res.data === 'object') {
                  const arrayKey = Object.keys(res.data).find(key => Array.isArray(res.data[key]));
                  if (arrayKey) data = res.data[arrayKey];
                }
                return { seriesName, data };
              })
              .catch(() => ({ seriesName, data: [] }));
          });
          
          Promise.all(fetchPromises)
            .then((results) => {
              const dataMap: {[key: string]: any[]} = {};
              results.forEach((r) => { dataMap[r.seriesName] = r.data; });
              setSeriesData(dataMap);
            })
            .finally(() => setLoading(false));
        }
      }
    }
  }, [component.type, component.series]);

  // Chart and metric card data fetching effect (legacy single data_binding)
  useEffect(() => {
    if (["bar-chart", "line-chart", "pie-chart", "radial-bar-chart", "radar-chart", "metric-card", "table"].includes(component.type)) {
      const endpoint = component.data_binding?.endpoint;
      if (endpoint) {
        setLoading(true);
        setError(null);
        // Always use backend base URL for relative endpoints
        const backendBase = process.env.REACT_APP_API_URL || "http://localhost:8000";
        
        // Check if table has lookup columns - if so, request detailed data with joins
        const hasLookupColumns = component.chart?.columns?.some(
          (col: any) => typeof col === 'object' && col.column_type === 'lookup'
        );
        
        // Check if data_binding uses nested fields (dot notation like measures.value)
        const hasNestedFields = isNestedField(component.data_binding?.label_field) || 
                                isNestedField(component.data_binding?.data_field);
        
        // Add detailed=true query param if there are lookup columns or nested fields
        const urlParams = (hasLookupColumns || hasNestedFields) ? '?detailed=true' : '';
        const url = endpoint.startsWith("/") 
          ? backendBase + endpoint + urlParams
          : endpoint + urlParams;
        
        axios.get(url)
          .then((res) => {
            let data: any[] = [];
            
            // If response is already an array, use it directly
            if (Array.isArray(res.data)) {
              data = res.data;
            } 
            // If response is an object, try to find the first array property
            else if (res.data && typeof res.data === 'object') {
              // Look for common array property names first
              const commonArrayKeys = ['data', 'results', 'items', 'records', 'list'];
              let foundKey = commonArrayKeys.find(key => Array.isArray(res.data[key]));
              
              // If not found, search for any array property
              if (!foundKey) {
                foundKey = Object.keys(res.data).find(key => Array.isArray(res.data[key]));
              }
              
              if (foundKey) {
                data = res.data[foundKey];
                console.log(`[Chart Data] Found array in property: ${foundKey}`);
              }
            }
            
            setChartData(data);
          })
          .catch((err) => {
            console.error("[Chart Data] Error loading data:", err);
            setError("Error loading data");
            setChartData([]);
          })
          .finally(() => setLoading(false));
      }
    }
  }, [component.type, component.data_binding?.endpoint]);

  // Data list fetching effect
  useEffect(() => {
    if (component.type === "data-list" && component.data_sources && component.data_sources.length > 0) {
      const source = component.data_sources[0];
      const endpoint = source.endpoint || `/${source.domain?.toLowerCase()}/`;
      if (endpoint) {
        const backendBase = process.env.REACT_APP_API_URL || "http://localhost:8000";
        const url = endpoint.startsWith("/") ? backendBase + endpoint : endpoint;
        axios.get(url)
          .then((res) => {
            let data = Array.isArray(res.data) ? res.data : (res.data.results || []);
            setListData(data);
          })
          .catch(() => setListData([]));
      }
    }
  }, [component.type, component.data_sources]);

  // Derived data for charts
  const preparedSeries = prepareSeries(normalizedSeries, seriesData);
  const hasSeries = preparedSeries.length > 0;
  const seriesChartData = hasSeries ? prepareChartDataFromSeries(preparedSeries, seriesData) : [];
  const defaultLabelField = component.data_binding?.label_field || "name";
  const defaultDataField = component.data_binding?.data_field || "value";
  const resolvedLabelField = hasSeries ? "name" : defaultLabelField;
  const resolvedDataField = hasSeries
    ? (preparedSeries.length === 1 ? preparedSeries[0].name || defaultDataField : defaultDataField)
    : defaultDataField;
  const finalChartData = hasSeries
    ? (seriesChartData.length > 0 ? seriesChartData : chartData)
    : chartData;

  if (component.type === "container" || component.type === "wrapper" || component.type === "component") {
    // Use the actual HTML tag if available, otherwise default to div
    const validTags = ["section", "article", "header", "footer", "nav", "aside", "main", "div", "ul", "ol", "li"];
    const tagName = (component.tag && validTags.includes(component.tag.toLowerCase())) 
      ? component.tag.toLowerCase()
      : "div";
    
    // Check if this is a cell and has children
    const isCell = component.class_list?.includes('gjs-cell');
    const hasChildren = (component.children ?? []).length > 0;
    
    // If it's a cell with children, set height to auto
    const adjustedStyle = isCell && hasChildren
      ? { ...style, height: 'auto' }
      : style;

    // Filter out 'style' from attributes since we handle it separately as a React object
    const { style: _, ...safeAttributes } = component.attributes || {};

    return React.createElement(
      tagName,
      {
        id: component.id,
        style: adjustedStyle,
        className: component.class_list?.join(' '),
        ...safeAttributes
      },
      (component.children ?? []).map((child: any) => (
        <Renderer key={child.id} component={child} styles={styles} />
      ))
    );
  }

  if (component.type === "text") {
    // Use the actual HTML tag if available, otherwise default to p
    const validTags = ["h1", "h2", "h3", "h4", "h5", "h6", "p", "span", "div", "strong", "em", "li"];
    const tagName = (component.tag && validTags.includes(component.tag.toLowerCase())) 
      ? component.tag.toLowerCase()
      : "p";
    
    // Filter out 'style' from attributes since we handle it separately as a React object
    const { style: _, ...safeAttributes } = component.attributes || {};
    
    return React.createElement(
      tagName,
      {
        id: component.id,
        style: style,
        className: component.class_list?.join(' '),
        ...safeAttributes
      },
      component.content || ""
    );
  }

  if (component.type === "button" || component.type === "action-button") {
    // Check if this is a method button (from JSON attributes)
    const actionType = component.attributes?.["data-action-type"] || component.action_type;
    
    if (actionType === "run-method") {
      const isInstanceMethod = component.attributes?.["is-instance-method"] === "true" || component.attributes?.["is-instance-method"] === true;
      const instanceSource = component.attributes?.["instance-source"];
      const endpoint = component.attributes?.endpoint || "";
      const inputParameters = component.attributes?.["input-parameters"] || {};
      
      // Convert input parameters from JSON format to MethodParameter array
      const parameters = Object.entries(inputParameters).map(([name, type]) => ({
        name,
        type: String(type),
        required: true,
      }));
      
      return (
        <MethodButton
          endpoint={endpoint}
          label={component.attributes?.["button-label"] || component.label || component.name || "Execute"}
          parameters={parameters}
          isInstanceMethod={isInstanceMethod}
          instanceSourceTableId={instanceSource}
          className={component.class_list?.join(' ')}
          style={style}
          backendUrl={process.env.REACT_APP_API_URL || "http://localhost:8000"}
        />
      );
    }
    
    // Check if this is a method button (legacy method_config)
    if (component.method_config) {
      const methodConfig = component.method_config;
      return (
        <MethodButton
          entityType={methodConfig.entity_type}
          entityId={methodConfig.entity_id}
          methodName={methodConfig.method_name}
          label={component.label || component.name || methodConfig.method_name}
          parameters={methodConfig.parameters || []}
          isClassMethod={methodConfig.is_class_method || false}
          className={component.class_list?.join(' ')}
          style={style}
          backendUrl={process.env.REACT_APP_API_URL || "http://localhost:8000"}
        />
      );
    }

    const handleClick = () => {
      // Handle button events
      if (component.events && Array.isArray(component.events)) {
        component.events.forEach((event: any) => {
          if (event.type === "onClick" && event.actions) {
            event.actions.forEach((action: any) => {
              if (action.kind === "Transition" && action.target_screen_path) {
                navigate(action.target_screen_path);
              } else if (action.kind === "Transition" && action.target_screen) {
                // Fallback to target screen name if path not available
                const targetPath = `/${action.target_screen.toLowerCase().replace(/\s+/g, '-')}`;
                navigate(targetPath);
              }
            });
          }
        });
      }
      // Fallback to targetScreen if events not available
      else if (component.target_screen_path) {
        navigate(component.target_screen_path);
      }
    };
    
    // Filter out 'style' from attributes
    const { style: _, ...safeAttributes } = component.attributes || {};
    
    return (
      <button
        id={component.id}
        type={component.attributes?.type || "button"}
        style={style}
        className={component.class_list?.join(' ')}
        onClick={handleClick}
        {...safeAttributes}
      >
        {component.label || component.name || "Button"}
      </button>
    );
  }

  if (component.type === "link" || component.type === "link-button") {
    const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) => {
      // Handle internal navigation
      if (component.target_screen_path && !component.url?.startsWith('http') && component.url !== '#') {
        e.preventDefault();
        navigate(component.target_screen_path);
      }
      // Let default link behavior handle external URLs
    };
    
    // Filter out 'style' from attributes
    const { style: _, ...safeAttributes } = component.attributes || {};
    
    return (
      <a
        id={component.id}
        href={component.url || "#"}
        target={component.target || undefined}
        rel={component.rel || undefined}
        style={style}
        className={component.class_list?.join(' ')}
        onClick={handleClick}
        {...safeAttributes}
      >
        {component.label || component.name || ""}
      </a>
    );
  }

  if (component.type === "image") {
    // Filter out 'style' from attributes
    const { style: _, ...safeAttributes } = component.attributes || {};
    
    return (
      <img
        id={component.id}
        src={component.src || ""}
        alt={component.alt || component.description || ""}
        style={style}
        className={component.class_list?.join(' ')}
        {...safeAttributes}
      />
    );
  }

  if (component.type === "input") {
    // Filter out 'style' from attributes
    const { style: _, ...safeAttributes } = component.attributes || {};
    
    return (
      <input
        id={component.id}
        type={component.input_type?.toLowerCase() || "text"}
        placeholder={component.attributes?.placeholder || ""}
        style={style}
        className={component.class_list?.join(' ')}
        {...safeAttributes}
      />
    );
  }

  if (component.type === "form") {
    const handleSubmit = (e: React.FormEvent) => {
      e.preventDefault();
      // Handle form submission
      console.log("Form submitted:", component.name);
    };
    
    // Filter out 'style' from attributes
    const { style: _, ...safeAttributes } = component.attributes || {};
    
    return (
      <form
        id={component.id}
        onSubmit={handleSubmit}
        style={style}
        className={component.class_list?.join(' ')}
        {...safeAttributes}
      >
        {(component.inputs || []).map((input: any) => (
          <div key={input.id} style={{ marginBottom: "10px" }}>
            <label htmlFor={input.id} style={{ display: "block", marginBottom: "5px" }}>
              {input.label || input.id}
            </label>
            <Renderer key={input.id} component={{ ...input, type: "input" }} styles={styles} />
          </div>
        ))}
        <button type="submit">Submit</button>
      </form>
    );
  }

  if (component.type === "menu") {
    // Filter out 'style' from attributes
    const { style: _, ...safeAttributes } = component.attributes || {};
    
    return (
      <nav id={component.id} style={style} className={component.class_list?.join(' ')} {...safeAttributes}>
        <ul style={{ listStyle: "none", padding: 0, margin: 0 }}>
          {(component.items || []).map((item: any, index: number) => (
            <li key={index} style={{ display: "inline-block", marginRight: "15px" }}>
              <a
                href={item.url || "#"}
                target={item.target || undefined}
                rel={item.rel || undefined}
              >
                {item.label}
              </a>
            </li>
          ))}
        </ul>
      </nav>
    );
  }

  if (component.type === "data-list") {
    // Filter out 'style' from attributes
    const { style: _, ...safeAttributes } = component.attributes || {};
    
    return (
      <div id={component.id} style={style} className={component.class_list?.join(' ')} {...safeAttributes}>
        <ul>
          {listData.map((item: any, index: number) => (
            <li key={index}>{JSON.stringify(item)}</li>
          ))}
        </ul>
      </div>
    );
  }

  if (component.type === "embedded-content") {
    // Filter out 'style' from attributes
    const { style: _, ...safeAttributes } = component.attributes || {};
    
    return (
      <iframe
        id={component.id}
        src={component.src || ""}
        title={component.description || component.name}
        style={style}
        className={component.class_list?.join(' ')}
        {...safeAttributes}
      />
    );
  }
{% if 'RadarChart' in used_components %}
  if (component.type === "radar-chart") {
    if (loading) return <div id={component.id}>Loading data...</div>;
    if (error) return <div id={component.id}>{error}</div>;
    
    return (
      <RadarChartComponent
        id={component.id}
        title={component.title || component.name}
        color={component.color}
        data={finalChartData}
        series={preparedSeries}
        labelField={resolvedLabelField}
        dataField={resolvedDataField}
        options={component.chart || {}}
        styles={style}
      />
    );
  }
{% endif %}

{% if 'BarChart' in used_components %}
  if (component.type === "bar-chart") {
    if (loading) return <div id={component.id}>Loading data...</div>;
    if (error) return <div id={component.id}>{error}</div>;
    
    return (
      <BarChartComponent
        id={component.id}
        title={component.title || component.name}
        color={component.color}
        data={finalChartData}
        series={preparedSeries}
        labelField={resolvedLabelField}
        dataField={resolvedDataField}
        options={component.chart || {}}
        styles={style}
      />
    );
  }
{% endif %}

{% if 'LineChart' in used_components %}
  if (component.type === "line-chart") {
    if (loading) return <div id={component.id}>Loading data...</div>;
    if (error) return <div id={component.id}>{error}</div>;
    
    return (
      <LineChartComponent
        id={component.id}
        title={component.title || component.name}
        color={component.color}
        data={finalChartData}
        series={preparedSeries}
        labelField={resolvedLabelField}
        dataField={resolvedDataField}
        options={component.chart || {}}
        styles={style}
      />
    );
  }
{% endif %}

{% if 'PieChart' in used_components %}
  if (component.type === "pie-chart") {
    if (loading) return <div id={component.id}>Loading data...</div>;
    if (error) return <div id={component.id}>{error}</div>;
    
    return (
      <PieChartComponent
        id={component.id}
        title={component.title || component.name}
        data={finalChartData}
        series={preparedSeries}
        labelField={resolvedLabelField}
        dataField={resolvedDataField}
        options={component.chart || {}}
        styles={style}
      />
    );
  }
{% endif %}

{% if 'RadialBarChart' in used_components %}
  if (component.type === "radial-bar-chart") {
    if (loading) return <div id={component.id}>Loading data...</div>;
    if (error) return <div id={component.id}>{error}</div>;
    
    return (
      <RadialBarChartComponent
        id={component.id}
        title={component.title || component.name}
        data={finalChartData}
        series={preparedSeries}
        labelField={resolvedLabelField}
        dataField={resolvedDataField}
        options={component.chart || {}}
        styles={style}
      />
    );
  }
{% endif %}

{% if 'Table' in used_components %}
  if (component.type === "table") {
    if (loading) return <div id={component.id}>Loading data...</div>;
    if (error) return <div id={component.id}>{error}</div>;
    // Merge action-buttons from attributes into options
    const options = {
      ...(component.chart || {}),
      actionButtons: component.attributes?.["action-buttons"] ?? false,
    };
    return (
      <TableComponent
        id={component.id}
        title={component.title || component.name}
        data={chartData}
        options={options}
        styles={style}
        dataBinding={component.data_binding}
      />
    );
  }
{% endif %}
{% if 'MetricCard' in used_components %}
  if (component.type === "metric-card") {
    if (loading) return <div id={component.id}>Loading data...</div>;
    if (error) return <div id={component.id}>{error}</div>;
    
    // Calculate the last value from the data
    let metricValue = 0;
    if (chartData && chartData.length > 0) {
      const lastItem = chartData[chartData.length - 1];
      const dataField = component.data_binding?.data_field;
      
      // Try to get value from the specified data field
      if (dataField && lastItem[dataField] !== undefined) {
        metricValue = Number(lastItem[dataField]) || 0;
      } 
      // Fallback: try common field names
      else {
        const commonFields = ['value', 'count', 'amount', 'total', 'sum'];
        for (const field of commonFields) {
          if (lastItem[field] !== undefined) {
            metricValue = Number(lastItem[field]) || 0;
            break;
          }
        }
      }
    }
    
    return (
      <MetricCardComponent
        id={component.id}
        metric-title={component.metric?.metricTitle || component.title || "Metric"}
        format={component.metric?.format || "number"}
        value-color={component.metric?.valueColor || "#2c3e50"}
        value-size={component.metric?.valueSize || 32}
        show-trend={component.metric?.showTrend !== false}
        positive-color={component.metric?.positiveColor || "#27ae60"}
        negative-color={component.metric?.negativeColor || "#e74c3c"}
        value={metricValue}
        trend={12}
        data_binding={component.data_binding}
      />
    );
  }
{% endif %}

  if (component.type === "agent-component") {
    return (
      <AgentComponent
        id={component.id}
        agent-name={component["agent-name"] || component.agent_name || ""}
        agent-title={component["agent-title"] || component.agent_title || "BESSER Agent"}
        styles={style}
      />
    );
  }

  return (
    <div id={component.id} style={style}>
      <strong>{component.name || component.type}</strong>
      <pre style={{ whiteSpace: "pre-wrap" }}>
        {JSON.stringify(component, null, 2)}
      </pre>
    </div>
  );
};
