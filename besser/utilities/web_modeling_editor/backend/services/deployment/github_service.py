"""
GitHub Service for Repository Creation and Code Push.

Handles creating GitHub repositories and pushing generated code.
"""

import os
import base64
import tempfile
import shutil
from typing import Optional, Dict, Any, List
from pathlib import Path
import requests
from datetime import datetime


class GitHubService:
    """Service for interacting with GitHub API."""
    
    def __init__(self, access_token: str):
        """
        Initialize GitHub service with user's access token.
        
        Args:
            access_token: GitHub OAuth access token
        """
        self.access_token = access_token
        self.base_url = "https://api.github.com"
        self.headers = {
            "Authorization": f"Bearer {access_token}",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28"
        }
    
    def get_authenticated_user(self) -> Dict[str, Any]:
        """
        Get information about the authenticated user.
        
        Returns:
            User information dictionary
        """
        response = requests.get(
            f"{self.base_url}/user",
            headers=self.headers,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    
    def create_repository(
        self,
        repo_name: str,
        description: str = "Web application generated by BESSER",
        is_private: bool = False
    ) -> Dict[str, Any]:
        """
        Create a new GitHub repository in user's account.
        
        Args:
            repo_name: Name for the repository
            description: Repository description
            is_private: Whether to make the repository private
            
        Returns:
            Repository information dictionary
        """
        data = {
            "name": repo_name,
            "description": description,
            "private": is_private,
            "auto_init": False,  # We'll push code ourselves
            "has_issues": True,
            "has_projects": False,
            "has_wiki": False
        }
        
        response = requests.post(
            f"{self.base_url}/user/repos",
            headers=self.headers,
            json=data,
            timeout=10
        )
        response.raise_for_status()
        return response.json()
    
    def delete_repository(self, owner: str, repo_name: str) -> bool:
        """
        Delete a repository (use with caution!).
        
        Args:
            owner: Repository owner username
            repo_name: Repository name
            
        Returns:
            True if deleted successfully
        """
        response = requests.delete(
            f"{self.base_url}/repos/{owner}/{repo_name}",
            headers=self.headers,
            timeout=10
        )
        return response.status_code == 204
    
    def push_directory_to_repo(
        self,
        owner: str,
        repo_name: str,
        directory_path: str,
        commit_message: str = "Initial commit - Generated by BESSER"
    ) -> Dict[str, Any]:
        """
        Push entire directory contents to GitHub repository.
        
        Uses GitHub Contents API to upload files one by one.
        For large repos, consider using git push instead.
        
        Args:
            owner: Repository owner username
            repo_name: Repository name
            directory_path: Path to directory containing files to push
            commit_message: Commit message
            
        Returns:
            Dictionary with push results
        """
        results = {
            "uploaded_files": [],
            "failed_files": [],
            "total_files": 0
        }
        
        directory = Path(directory_path)
        
        # Get all files recursively
        all_files = list(directory.rglob("*"))
        all_files = [f for f in all_files if f.is_file()]
        
        results["total_files"] = len(all_files)
        
        for file_path in all_files:
            try:
                # Get relative path from directory
                rel_path = file_path.relative_to(directory)
                github_path = str(rel_path).replace("\\", "/")
                
                # Read file content
                with open(file_path, "rb") as f:
                    content = f.read()
                
                # Encode to base64
                content_b64 = base64.b64encode(content).decode("utf-8")
                
                # Upload to GitHub
                self._upload_file(
                    owner=owner,
                    repo_name=repo_name,
                    file_path=github_path,
                    content_b64=content_b64,
                    message=commit_message
                )
                
                results["uploaded_files"].append(github_path)
                
            except Exception as e:
                results["failed_files"].append({
                    "file": str(file_path),
                    "error": str(e)
                })
        
        return results
    
    def _upload_file(
        self,
        owner: str,
        repo_name: str,
        file_path: str,
        content_b64: str,
        message: str
    ) -> Dict[str, Any]:
        """
        Upload a single file to GitHub repository.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            file_path: Path within repository
            content_b64: Base64-encoded file content
            message: Commit message
            
        Returns:
            Response from GitHub API
        """
        data = {
            "message": message,
            "content": content_b64
        }
        
        response = requests.put(
            f"{self.base_url}/repos/{owner}/{repo_name}/contents/{file_path}",
            headers=self.headers,
            json=data,
            timeout=30
        )
        response.raise_for_status()
        return response.json()
    
    def create_readme(
        self,
        owner: str,
        repo_name: str,
        app_name: str,
        deploy_instructions: bool = True
    ) -> Dict[str, Any]:
        """
        Create a README.md file with deployment instructions.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            app_name: Application name
            deploy_instructions: Include deployment instructions
            
        Returns:
            GitHub API response
        """
        readme_content = self._generate_readme(app_name, deploy_instructions)
        content_b64 = base64.b64encode(readme_content.encode("utf-8")).decode("utf-8")
        
        return self._upload_file(
            owner=owner,
            repo_name=repo_name,
            file_path="README.md",
            content_b64=content_b64,
            message="Add README with deployment instructions"
        )
    
    def _generate_readme(self, app_name: str, deploy_instructions: bool) -> str:
        """Generate README.md content."""
        readme = f"""# {app_name}

Web application generated by [BESSER](https://github.com/BESSER-PEARL/BESSER).

## About

This application was created using the BESSER Web Modeling Editor, a low-code open-source platform for building software.

"""
        
        if deploy_instructions:
            readme += """## Project Structure

```
â”œâ”€â”€ frontend/          # React TypeScript frontend
â”œâ”€â”€ backend/           # FastAPI Python backend
â”œâ”€â”€ agent/            # BESSER agent (if included)
â”œâ”€â”€ render.yaml       # Render deployment config (one-click deploy!)
â”œâ”€â”€ .env.production   # Production environment variables
â””â”€â”€ docker-compose.yml # Local development setup
```

## ðŸš€ Deploy to Cloud

### One-Click Deployment with Render
[![Deploy to Render](https://render.com/images/deploy-to-render-button.svg)](https://render.com/deploy?repo=https://github.com/{owner}/{repo})

**Why Render?**
- âœ… **Truly FREE** - 750 hours/month for both frontend + backend
- âœ… **One-Click Deploy** - No manual configuration needed
- âœ… **No Payment Info Required** - Won't ask for credit card
- âœ… **Auto SSL** - Free HTTPS certificates
- âš ï¸ Spins down after 15 min idle (cold start ~30s on first request)

Click the button above and Render will automatically:
1. Deploy your FastAPI backend
2. Deploy your React frontend
3. Connect them together
4. Give you live URLs!

## Local Development

### Frontend
```bash
cd frontend
npm install
npm start
# Opens at http://localhost:3000
```

### Backend
```bash
cd backend
pip install -r requirements.txt
uvicorn main_api:app --reload
# API at http://localhost:8000
```

### Docker (Full Stack)
```bash
docker-compose up
# Frontend: http://localhost:3000
# Backend: http://localhost:8000
```

## Technology Stack

- **Frontend**: React with TypeScript, Create React App
- **Backend**: FastAPI (Python 3.9+)
- **Agent**: BESSER agent framework (optional)

## Generated by BESSER

Learn more about BESSER:
- [GitHub](https://github.com/BESSER-PEARL/BESSER)
- [Documentation](https://besser.readthedocs.io/)
- [Web Editor](https://editor.besser-pearl.org/)

---

*Generated on {datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")} UTC*
"""
        
        return readme
    
    def get_deployment_urls(
        self,
        owner: str,
        repo_name: str
    ) -> Dict[str, str]:
        """
        Get deployment URLs for Render platform.
        
        Args:
            owner: Repository owner
            repo_name: Repository name
            
        Returns:
            Dictionary with GitHub and Render deployment URLs
        """
        repo_url = f"https://github.com/{owner}/{repo_name}"
        
        return {
            "github": repo_url,
            "render": f"https://render.com/deploy?repo={repo_url}"
        }


def create_github_service(access_token: str) -> GitHubService:
    """
    Factory function to create GitHub service instance.
    
    Args:
        access_token: GitHub OAuth access token
        
    Returns:
        GitHubService instance
    """
    return GitHubService(access_token)
